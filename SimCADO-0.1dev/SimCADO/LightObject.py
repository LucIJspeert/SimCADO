###############################################################################
# LightObject
#
# DESCRIPTION
# The LightObject should appear in the form of a FITS cube which stays on
# disk and is never fully read into RAM. A 4x oversampled 4k x 4k image using
# float32 in python takes up 2GB of RAM. Therefore the simplest way to avoid
# memory problems is to never read in the full data cube to begin with.
# We can get around this problem by reading in the spectral channels one by one.
# The LightObject must therefore only contain a pointer to a copy of the 
# relevant layers of the FITS file, which can be manipulated and collapsed.
#
# LightObject will need to contain spatial and wavelength information:
# - pix_res
# - pix_width
# - pix_height
# - lam_res
# - lam_bin_centers
# - lam_bin_edges
#
# LightObject will be in photons/s/m2/pixel_fov/wavelength_slice. Therefore
# LightObject will also need to know the telescope collecting area and 
# integration time to convert the cube into photons/spaxel. The following info
# should be pulled from the UserCommands dictionary:
# - area
# - exptime
#
# It should also contain an image of the flattened cube. The image contains
# info about where the brightest pixels are and where the empty pixels are. 
#
# A LightObject contains methods for each effect encountered along the 
# optical train. These methods will be applied to the copy of the useful parts
# of the original FITS file.
#
# - __init__(UserCommands)
#     Pull out the useful section the input cube and then convert it to photons
#
# - add_atmosphere(AtmosphereModel)
#     AtmosphereModel contains the transmission curve for the atmosphere and the
#       background photons. 
#     The number of photons in each LightObject spaxel should be reduced based 
#       on the rebinned transmission curve.
#     Background photons should be added to each spaxel based on a rebinned
#       emission curve
#   
# - apply_psf_effect(PSFCube)
#     PSFCube contains a series of PSFs corresponding to the spectral slices in
#       the LightObject
#     Each "science" slice should be generated by summing up all the photons in
#       the spectra read in from the fits file. 
#     The science slices should them by convolved with the PSF slices
#
# - apply_spectral_effect(SpectralCurve)
#     Each spectrum in the input cube that has more photons than the set
#       threshold over the whole bandpass should be considered
#     Each spectrum is acted on by the SpectralCurve. If it is an instance of
#       TransmissionCurve, multiply. If it is an EmissionCurve, add together
#
# - collapse()
#     Add all the science slices together into a single 2D array
#
# - apply_plane_effect(PlaneEffect)
#     Each PlaneEffect consists of 3 layers: x-shift, y-shift and weight.
#     Shift each pixel in the plane along the vector (x-shift, y-shift) and 
#       multiply it by the value in weight.
#     If the shift is non-integer (i.e. sqrt(x^2+y^2)%1 > 0) spread the photons
#       over the adjoining pixels 
#
# - make_detector_image(Detector)
#     A Detector object contains an array of noise, generated by the NGHxRG
#       package as well as the parameters for readout, i.e. Gain, Dark, etc
#     The LightObject 2D array should be converted to electrons and then 
#       combined with the Detector noise array and the read noise
#     Other detector effects should also be taken care of, e.g:
#       - saturation, 
#       - streaking, 
#       - dead pixels and lines
#       - detector gaps 
#
# - apply_grating(SpectralGrating)
#     A place-holder method to do what needs to be done to the photons in order
#       to simulate the effects of a spectral grating
#
#
# Classes:
#  LightObject()
#  - __init__(UserCommands) 
#  - add_atmosphere(AtmosphereModel)
#  - apply_psf_effect(PSFCube) 
#  - apply_spectral_effect(SpectralCurve)
#  - collapse()
#  - apply_plane_effect(PlaneEffect)
#  - make_detector_image(Detector)
#  - apply_grating(GratingCube)
#
#



from astropy.io import fits

## These classes and functions are exported to the package
__all__ = ["LightObject"]

class LightObject(object):
    """
	Cube holding the light passing through the optical system
	"""

    def __init__(self, cmds):
		"""
		The LightObject is a cube in memory, possibly many 10s of GB big.
		It should already by in units of photons/s/m2/pixel_fov/wavelength_slice
		"""

		self.cmds   = cmds
		hdr = fits.getheader(cmds["OBS_INPUT_FILENAME"], cmds["OBS_FITS_EXT"])
		self.header = hdr
		
		self.lam_res = hdr["CDELT3"]
		self.lam_min = hdr["CRPIX3"] + hdr["CRVAL3"] * hdr["CDELT3"]
		self.lam_max = hdr[]
		
		self.lam_bin_centers
		self.lam_bin_edges
		
		self.shape = (0,0)
		self.total_photons_array = np.zeros(self.shape)
		
		self.info = dict([])
        self.info['Filename'] = os.path.basename(fname)
        self.info['Path'] = os.path.dirname(fname)
        
        fp = fits.open(fname)
        self.header = fp[extnum].header
        fp.close()
        

    def __repr__(self):
        string = "LightCube\nFile name: %s" % self.info['Filename']
        return string
    
    def apply_atmosphere(self, atmosphere_model):
        self.info['atmosphere'] = 'applied'

    def apply_psf(self, psf_cube):
        self.info['psf'] = 'applied'

    def apply_throughput(self, throughput):
        self.info['throughput'] = 'applied'

    def collapse(self):
        self.info['collapse'] = 'applied'

    def apply_spectral_effect(self, plane_effect):
        self.info['geometry'] = 'applied'

    def make_detector_image(self, detector):
        self.info['detector_image'] = 'applied'

    def add_background(self, bg_level):
        self.info['background'] = 'applied'

        
