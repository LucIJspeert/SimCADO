{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to SimCADocs\n\n\nThe (slowly expanding) documentation base for SimCADO\n\n\nSimCADO in a nutshell\n\n\nSimCADO is a python package designed to simulate the effects of the Atmosphere, E-ELT, and MICADO instrument on incoming light. The current version (v0.2) can simulate the MICADO imaging modi (4mas and 1.5mas per pixel in the wavelength range 0.7\u00b5m to 2.5\u00b5m).\n\n\nReference Material\n\n\n\n\n\n\nThe inner workings of SimCADO are described in detail in \nLeschinski et al. (2016)\n\n\n\n\n\n\nThe current status of MICADO is described in \nDavies et al. (2016)\n\n\n\n\n\n\nRunning a simulation in 3 lines\n\n\nThe easiest way to run a simulation is to create, or load, a Source object and then call the \n.run()\n command. If you specify a filename, the resulting image will be output to a FITS file under that name. If you do not specify a filename, the output will be returned to the console/notebook as an \nastropy.io.fits.HDUList\n object.\n\n\nTo begin, we will import the simcado module (assuming it is already installed).\n\n\n>>> import simcado as sim\n\n\n\n\nAt the very least, we need to create a \nSource\n object which contains both spatial and spectral information on our object of interest. Here we use the built-in command \n.source.source_1E4_Msun_cluster()\n to create a \nSource\n-object for a 10000-Msun stellar cluster. (See \nCreating Sources\n for more information).\n\n\n>>> src = sim.source.source_1E4_Msun_cluster()\n\n\n\n\nWe now pass the \nsource\n object through SimCADO. This is as easy as calling \n.run()\n. If we specify a \nfilename\n, SimCADO will write the output to disk in the form of a FITS file. If no \nfilename\n is given, then SimCADO returns an \nastropy.io.fits\n object to the console/notebook.\n\n\n>>> sim.run(src, filename=\"my_first_sim.fits\")\n\n\n\n\nThat's it. Of course SimCADO can also go in the other direction, providing many more levels of complexity, but for that the reader is directed to the examples pages and/or the \nAPI\n documentation\n\n\nSimCADO building blocks\n\n\nFor a brief explanation of how SimCADO works and which classes are relevant, please see either the \nGetting Started\n or \nSimCADO in depth\n section.\n\n\nContact\n\n\nFor questions and complaints alike, please contact the authors:\n\n\n\n\nkieran.leschinski@univie.ac.at\n\n\noliver.czoske@univie.ac.at\n\n\n\n\nDevelopers (Vienna):\n Kieran Leschinski, Oliver Czoske\n\n\nData Flow Team Leader (Gronigen):\n Gijs Verdoes Kleijn\n\n\nMICADO home office (MPE):\n http://www.mpe.mpg.de/ir/micado",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-simcadocs",
            "text": "The (slowly expanding) documentation base for SimCADO",
            "title": "Welcome to SimCADocs"
        },
        {
            "location": "/#simcado-in-a-nutshell",
            "text": "SimCADO is a python package designed to simulate the effects of the Atmosphere, E-ELT, and MICADO instrument on incoming light. The current version (v0.2) can simulate the MICADO imaging modi (4mas and 1.5mas per pixel in the wavelength range 0.7\u00b5m to 2.5\u00b5m).",
            "title": "SimCADO in a nutshell"
        },
        {
            "location": "/#reference-material",
            "text": "The inner workings of SimCADO are described in detail in  Leschinski et al. (2016)    The current status of MICADO is described in  Davies et al. (2016)",
            "title": "Reference Material"
        },
        {
            "location": "/#running-a-simulation-in-3-lines",
            "text": "The easiest way to run a simulation is to create, or load, a Source object and then call the  .run()  command. If you specify a filename, the resulting image will be output to a FITS file under that name. If you do not specify a filename, the output will be returned to the console/notebook as an  astropy.io.fits.HDUList  object.  To begin, we will import the simcado module (assuming it is already installed).  >>> import simcado as sim  At the very least, we need to create a  Source  object which contains both spatial and spectral information on our object of interest. Here we use the built-in command  .source.source_1E4_Msun_cluster()  to create a  Source -object for a 10000-Msun stellar cluster. (See  Creating Sources  for more information).  >>> src = sim.source.source_1E4_Msun_cluster()  We now pass the  source  object through SimCADO. This is as easy as calling  .run() . If we specify a  filename , SimCADO will write the output to disk in the form of a FITS file. If no  filename  is given, then SimCADO returns an  astropy.io.fits  object to the console/notebook.  >>> sim.run(src, filename=\"my_first_sim.fits\")  That's it. Of course SimCADO can also go in the other direction, providing many more levels of complexity, but for that the reader is directed to the examples pages and/or the  API  documentation",
            "title": "Running a simulation in 3 lines"
        },
        {
            "location": "/#simcado-building-blocks",
            "text": "For a brief explanation of how SimCADO works and which classes are relevant, please see either the  Getting Started  or  SimCADO in depth  section.",
            "title": "SimCADO building blocks"
        },
        {
            "location": "/#contact",
            "text": "For questions and complaints alike, please contact the authors:   kieran.leschinski@univie.ac.at  oliver.czoske@univie.ac.at   Developers (Vienna):  Kieran Leschinski, Oliver Czoske  Data Flow Team Leader (Gronigen):  Gijs Verdoes Kleijn  MICADO home office (MPE):  http://www.mpe.mpg.de/ir/micado",
            "title": "Contact"
        },
        {
            "location": "/GettingStarted/",
            "text": "Getting Started with SimCADO\n\n\nSimCADO can be super easy to use, or super complicated. The level of complexity is completely up to the user. Regardless of your intended use for SimCADO, it's probably a good idea to at least have a vague understanding of what is going on during a simulation.\n\n\nBehind the scenes of SimCADO\n\n\nSimCADO uses 4 main classes during a simulation: \n\n\n\n\nSource\n holds spatial and spectral information about the astronomical source of photons, e.g. galaxy, star cluster, etc.\n\n\nOpticalTrain\n contains information on the various elements along the optical path, e.g. mirrors reflectivity curves, PSFs, instrumental distortion, etc.\n\n\nDetector\n represents the focal plane detector array and contains information on the electronic characteristics of the detector chips and their physical positions.\n\n\nUserCommands\n is a dictionary of all the important keywords needed by SimCADO to run the simultationm, e.g. \nOBS_EXPTIME\n (exposure time) or \nINST_FILTER_TC\n (filter curve)\n\n\n\n\nSource\n\n\nFor full details, please see the \nAPI\n and examples of \nSource Objects\n\n\nThe \nSource\n class is probably the most important class for testing science cases. Therefore spending time on creating accurate \nSource\n representations of the object of interest is key to getting good results with SimCADO. \nSource\n objects can be created from scratch, with functions provided by SimCADO, or by loading in a pre-existing \nSource\n-FITS file.\n\n\nNote: SimCADO is CaSe SensITIVe!\n SimCADO has the class \nsimcado.Source()\n and the module \nsimcado.source\n. These should not be confused. \nsimcado.source\n is the module which contains the class \nSource\n and all the helper functions for creating various types of \nSource\n objects. In fact the source code for the  class \nSource\n is actually at \nsimcado.source.Source\n, however to make things easy, \nSource\n is available directly as\nsimcado.Source()\n. Be careful and remember \nsimcado.Source != simcado.source\n.\n\n\nFor a description of the \nSource\n object, and the \nsource\n module, see \nHow SimCADO works\n.\n\n\nLoading a pre-existing \nSource\n object\n\n\nTo load in a pre-existing \nSource\n, specify the keyword \nfilename=\n when initialising the \nSource\n object.\n\n\n>>> import simcado as sim\n>>> my_src = sim.Source(filename=\"star_grid.fits\")\n\n\n\n\nSource\n-FITS files have a very specific file format, so it's best to only import files that were generated directly from other \nSource\n objects. It's a chicken/egg scenario, which is why the next section deals with creating \nSource\n objects in memory. For a description of the file format for saved \nSource\n objects, see \n\"File Format of saved Source objects\"\n.\n\n\nMaking a \nSource\n with SimCADO's in-built functions\n\n\nThe \nsimcado.source\n module provides an ever-increasing series of functions to create \nSource\n objects in memory. These include, (from \nsimcado.source\n)\n\n\n\n\n.empty_sky()\n\n\n.star(mag, filter_name=\"K\", ...)\n\n\n.stars(mags, x, y, ...)\n\n\n.star_grid(n, mag_min, mag_max, ...)\n\n\n.source_1E4_Msun_cluster(distance=50000, ...)\n\n\n.source_from_image(images, lam, spectra, pix_res, ...)\n\n\n\n\nTwo useful functions here are \n.stars()\n and \n.source_from_image()\n\n\n\n\nstars()\n takes a list of magnitudes (and optionally spectral types) and positions for a common broad-band filter (default is \"K\") and generates a \nSource\n object with those stars in the field.\n\n\n\n\n>>> x, y = [-2.5, 0.7, 16.3], [3.3, -0.2, 25.1]\n>>> mags, spec_types = [25,21,28], [\"K0V\", \"A0III\", \"G2V\"]\n>>> filt = \"H\"\n>>>\n>>> my_src = sim.source.stars(mags=mags, x=x, y=y, filter_name=filt, spec_types=spec_types)\n\n\n\n\n\n\nsource_from_image()\n creates a \nSource\n based on a 2D numpy array provided by the user. The 2D array can come from anywhere, e.g. the data from a FITS image, a BITMAP image, from memory, etc. Alongside the image, the user must provide a spectrum (plus a vector with the bin centres) and the pixel field of view (e.g. 0.004 arcsec for MICADO). SimCADO then extracts all pixels from the image which have values above \nflux_threshold\n (defualt is 0) and saves these pixel coordinates. The spectrum provided is then connected to these pixel, and scaled by the pixel value.\n\n\n\n\n>>> # ... Create an image - a circle with a radius of 20 pixels on a grid 200 pixel wide\n>>> XX = np.array([np.arange(-100,101)]*201) \n>>> im = np.sqrt(XX**2 + XX.transpose()**2)\n>>> im[im>20] = 0; im[im>0] = 1\n>>>\n>>> # ... Pull in the spectrum for a G2V star with K=20\n>>> lam, spec = simcado.source.SED(\"G2V\", filter_name=\"K\", magnitude=20)\n>>>\n>>> # ... Make the source object\n>>> my_src = sim.source.source_from_image(images=im, lam=lam, spectra=spec, pix_res=0.004)\n\n\n\n\nsource_from_image()\n can also take a list of images if different spectra are to be assigned to each image. An example of this maybe for galaxies. The older population might be represented by image with an ellipse on it, while the positions of the star forming regions are shown on a different image with random scattered blobs. In this case, both images can be passed in a list to \nimages\n and the array passed to \nspectra\n must have dimensions (2,n) where n is the length of the spectra. \nNote\n the spectra must be on the same grid and be the same length.\n\n\nCreating a \nSource\n object from scratch\n\n\nTo create a \nSource\n object from scratch, we initialise the object by passing 5 (or 6) arrays. All the parameter names must be specified.\n\n\nsim.Source(lam=, spectra=, x=, y=, ref=, [weight=])\n\n\nwhere: \n+ \nx, y\n - [each a \nnumpy.ndarray\n]. Coordinates for each point source in the image in units of [arcsec] from the focal plane centre\n\n\n\n\n\n\nlam\n - [\nnumpy.ndarray\n]. An array with the centre of the wavelength bins in [um] for each unique spectrum\n\n\n\n\n\n\nspectra\n - [\nnumpy.ndarray\n]. An (n, m) array holding n spectra, each with m values. Default units are [ph/s]\nNote - \nlam\n and \nspectra\n should use a constant bin width. Variable bin widths leads to unpredictable results.\n\n\n\n\n\n\nref\n - [\nnumpy.ndarray\n]. An array to connect the point source at \nx[i]\n, \ny[i]\n to a unique spectrum at \nspectra[j]\n, i.e. \nref[i] = j\n\n\n\n\n\n\nOptional keywords can be specified:\n\n\n\n\nweight\n - [\nnumpy.ndarray\n], optional. If two sources share the same spectrum, but are at different distances or have different luminosities a scaling factor can be specified to the spectrum when applied to each specific point source.\n\n\nunits\n [default \n\"ph/s\"\n] is the units for the spectra, i.e. n phontons per second per spectral bin. The size of the spectral bins is resolution of the \n.lam\n array.\n\n\n\n\nCombining two (or more) \nSource\n objects\n\n\nSource\n objects can be created in different ways, but the underlying table-structure is the same. Therefore adding \nSource\n objects together means simply combining tables. The mathematical operator \n+\n can be used to do this:\n\n\n>>> # ... create a A0V star at (0,0) and a G2V star at (5,-5)\n>>> star_A0V = sim.source.star(20, position=(0,0), spec_type=\"A0V\")\n>>> star_G2V = sim.source.star(20, position=(5,-5), spec_type=\"G2V\")\n>>> \n>>> src_combi = star_A0V + star_G2V\n>>> \n>>> print(src_combi.x, src_combi.y)\n[0 5] [ 0 -5]\n\n\n\n\nBy adding different \nSource\n objects together, it is possible to build up complex objects that will be representative of the observed sky, e.g. old + new galaxy stellar population + gas emission + foreground stars\n\n\nSee \nexamples\n for how to use the \n*\n and \n-\n operators with a \nSource\n object\n\n\nSaving a \nSource\n object to disk\n\n\nThe \nSource\n object is saved as a FITS file with two extensions. See \nHow SimCADO works\n for more on the file structure.\n\n\n>>> src_combi.write(\"my_src.fits\")\n\n\n\n\nThe file can be read in at a later time by specifying \nfilename=\n when initialising a \nSource\n object - as stated above\n\n\n>>> my_src = sim.Source(filename=\"my_src.fits\")\n\n\n\n\nIn-built \nSource\n object for a 10\n4\n M\nO\n cluster\n\n\nAs a test object, SimCADO provides the function, with all distances in parsecs:\n\n\nsim.source.source_1E4_Msun_cluster(distance=50000, half_light_radius=1)\n\n\nOpticalTrain\n\n\nDetector\n\n\nUserCommands\n\n\nSimulating with SimCADO\n\n\nThe quick, the dirty and the ugly\n\n\nCreating \nSource\n objects\n\n\nBuilding your own simulation run\n\n\nCreating \nUserCommand\n objects\n\n\nCreating \nOpticalTrain\n objects\n\n\nCreating \nDetector\n array objects\n\n\nRunning the simulation\n\n\nThings to watch out for",
            "title": "Getting Started"
        },
        {
            "location": "/GettingStarted/#getting-started-with-simcado",
            "text": "SimCADO can be super easy to use, or super complicated. The level of complexity is completely up to the user. Regardless of your intended use for SimCADO, it's probably a good idea to at least have a vague understanding of what is going on during a simulation.",
            "title": "Getting Started with SimCADO"
        },
        {
            "location": "/GettingStarted/#behind-the-scenes-of-simcado",
            "text": "SimCADO uses 4 main classes during a simulation:    Source  holds spatial and spectral information about the astronomical source of photons, e.g. galaxy, star cluster, etc.  OpticalTrain  contains information on the various elements along the optical path, e.g. mirrors reflectivity curves, PSFs, instrumental distortion, etc.  Detector  represents the focal plane detector array and contains information on the electronic characteristics of the detector chips and their physical positions.  UserCommands  is a dictionary of all the important keywords needed by SimCADO to run the simultationm, e.g.  OBS_EXPTIME  (exposure time) or  INST_FILTER_TC  (filter curve)",
            "title": "Behind the scenes of SimCADO"
        },
        {
            "location": "/GettingStarted/#source",
            "text": "For full details, please see the  API  and examples of  Source Objects  The  Source  class is probably the most important class for testing science cases. Therefore spending time on creating accurate  Source  representations of the object of interest is key to getting good results with SimCADO.  Source  objects can be created from scratch, with functions provided by SimCADO, or by loading in a pre-existing  Source -FITS file.  Note: SimCADO is CaSe SensITIVe!  SimCADO has the class  simcado.Source()  and the module  simcado.source . These should not be confused.  simcado.source  is the module which contains the class  Source  and all the helper functions for creating various types of  Source  objects. In fact the source code for the  class  Source  is actually at  simcado.source.Source , however to make things easy,  Source  is available directly as simcado.Source() . Be careful and remember  simcado.Source != simcado.source .  For a description of the  Source  object, and the  source  module, see  How SimCADO works .",
            "title": "Source"
        },
        {
            "location": "/GettingStarted/#loading-a-pre-existing-source-object",
            "text": "To load in a pre-existing  Source , specify the keyword  filename=  when initialising the  Source  object.  >>> import simcado as sim\n>>> my_src = sim.Source(filename=\"star_grid.fits\")  Source -FITS files have a very specific file format, so it's best to only import files that were generated directly from other  Source  objects. It's a chicken/egg scenario, which is why the next section deals with creating  Source  objects in memory. For a description of the file format for saved  Source  objects, see  \"File Format of saved Source objects\" .",
            "title": "Loading a pre-existing Source object"
        },
        {
            "location": "/GettingStarted/#making-a-source-with-simcados-in-built-functions",
            "text": "The  simcado.source  module provides an ever-increasing series of functions to create  Source  objects in memory. These include, (from  simcado.source )   .empty_sky()  .star(mag, filter_name=\"K\", ...)  .stars(mags, x, y, ...)  .star_grid(n, mag_min, mag_max, ...)  .source_1E4_Msun_cluster(distance=50000, ...)  .source_from_image(images, lam, spectra, pix_res, ...)   Two useful functions here are  .stars()  and  .source_from_image()   stars()  takes a list of magnitudes (and optionally spectral types) and positions for a common broad-band filter (default is \"K\") and generates a  Source  object with those stars in the field.   >>> x, y = [-2.5, 0.7, 16.3], [3.3, -0.2, 25.1]\n>>> mags, spec_types = [25,21,28], [\"K0V\", \"A0III\", \"G2V\"]\n>>> filt = \"H\"\n>>>\n>>> my_src = sim.source.stars(mags=mags, x=x, y=y, filter_name=filt, spec_types=spec_types)   source_from_image()  creates a  Source  based on a 2D numpy array provided by the user. The 2D array can come from anywhere, e.g. the data from a FITS image, a BITMAP image, from memory, etc. Alongside the image, the user must provide a spectrum (plus a vector with the bin centres) and the pixel field of view (e.g. 0.004 arcsec for MICADO). SimCADO then extracts all pixels from the image which have values above  flux_threshold  (defualt is 0) and saves these pixel coordinates. The spectrum provided is then connected to these pixel, and scaled by the pixel value.   >>> # ... Create an image - a circle with a radius of 20 pixels on a grid 200 pixel wide\n>>> XX = np.array([np.arange(-100,101)]*201) \n>>> im = np.sqrt(XX**2 + XX.transpose()**2)\n>>> im[im>20] = 0; im[im>0] = 1\n>>>\n>>> # ... Pull in the spectrum for a G2V star with K=20\n>>> lam, spec = simcado.source.SED(\"G2V\", filter_name=\"K\", magnitude=20)\n>>>\n>>> # ... Make the source object\n>>> my_src = sim.source.source_from_image(images=im, lam=lam, spectra=spec, pix_res=0.004)  source_from_image()  can also take a list of images if different spectra are to be assigned to each image. An example of this maybe for galaxies. The older population might be represented by image with an ellipse on it, while the positions of the star forming regions are shown on a different image with random scattered blobs. In this case, both images can be passed in a list to  images  and the array passed to  spectra  must have dimensions (2,n) where n is the length of the spectra.  Note  the spectra must be on the same grid and be the same length.",
            "title": "Making a Source with SimCADO's in-built functions"
        },
        {
            "location": "/GettingStarted/#creating-a-source-object-from-scratch",
            "text": "To create a  Source  object from scratch, we initialise the object by passing 5 (or 6) arrays. All the parameter names must be specified.  sim.Source(lam=, spectra=, x=, y=, ref=, [weight=])  where: \n+  x, y  - [each a  numpy.ndarray ]. Coordinates for each point source in the image in units of [arcsec] from the focal plane centre    lam  - [ numpy.ndarray ]. An array with the centre of the wavelength bins in [um] for each unique spectrum    spectra  - [ numpy.ndarray ]. An (n, m) array holding n spectra, each with m values. Default units are [ph/s]\nNote -  lam  and  spectra  should use a constant bin width. Variable bin widths leads to unpredictable results.    ref  - [ numpy.ndarray ]. An array to connect the point source at  x[i] ,  y[i]  to a unique spectrum at  spectra[j] , i.e.  ref[i] = j    Optional keywords can be specified:   weight  - [ numpy.ndarray ], optional. If two sources share the same spectrum, but are at different distances or have different luminosities a scaling factor can be specified to the spectrum when applied to each specific point source.  units  [default  \"ph/s\" ] is the units for the spectra, i.e. n phontons per second per spectral bin. The size of the spectral bins is resolution of the  .lam  array.",
            "title": "Creating a Source object from scratch"
        },
        {
            "location": "/GettingStarted/#combining-two-or-more-source-objects",
            "text": "Source  objects can be created in different ways, but the underlying table-structure is the same. Therefore adding  Source  objects together means simply combining tables. The mathematical operator  +  can be used to do this:  >>> # ... create a A0V star at (0,0) and a G2V star at (5,-5)\n>>> star_A0V = sim.source.star(20, position=(0,0), spec_type=\"A0V\")\n>>> star_G2V = sim.source.star(20, position=(5,-5), spec_type=\"G2V\")\n>>> \n>>> src_combi = star_A0V + star_G2V\n>>> \n>>> print(src_combi.x, src_combi.y)\n[0 5] [ 0 -5]  By adding different  Source  objects together, it is possible to build up complex objects that will be representative of the observed sky, e.g. old + new galaxy stellar population + gas emission + foreground stars  See  examples  for how to use the  *  and  -  operators with a  Source  object",
            "title": "Combining two (or more) Source objects"
        },
        {
            "location": "/GettingStarted/#saving-a-source-object-to-disk",
            "text": "The  Source  object is saved as a FITS file with two extensions. See  How SimCADO works  for more on the file structure.  >>> src_combi.write(\"my_src.fits\")  The file can be read in at a later time by specifying  filename=  when initialising a  Source  object - as stated above  >>> my_src = sim.Source(filename=\"my_src.fits\")",
            "title": "Saving a Source object to disk"
        },
        {
            "location": "/GettingStarted/#in-built-source-object-for-a-104-mo-cluster",
            "text": "As a test object, SimCADO provides the function, with all distances in parsecs:  sim.source.source_1E4_Msun_cluster(distance=50000, half_light_radius=1)",
            "title": "In-built Source object for a 104 MO cluster"
        },
        {
            "location": "/GettingStarted/#opticaltrain",
            "text": "",
            "title": "OpticalTrain"
        },
        {
            "location": "/GettingStarted/#detector",
            "text": "",
            "title": "Detector"
        },
        {
            "location": "/GettingStarted/#usercommands",
            "text": "",
            "title": "UserCommands"
        },
        {
            "location": "/GettingStarted/#simulating-with-simcado",
            "text": "",
            "title": "Simulating with SimCADO"
        },
        {
            "location": "/GettingStarted/#the-quick-the-dirty-and-the-ugly",
            "text": "",
            "title": "The quick, the dirty and the ugly"
        },
        {
            "location": "/GettingStarted/#creating-source-objects",
            "text": "",
            "title": "Creating Source objects"
        },
        {
            "location": "/GettingStarted/#building-your-own-simulation-run",
            "text": "",
            "title": "Building your own simulation run"
        },
        {
            "location": "/GettingStarted/#creating-usercommand-objects",
            "text": "",
            "title": "Creating UserCommand objects"
        },
        {
            "location": "/GettingStarted/#creating-opticaltrain-objects",
            "text": "",
            "title": "Creating OpticalTrain objects"
        },
        {
            "location": "/GettingStarted/#creating-detector-array-objects",
            "text": "",
            "title": "Creating Detector array objects"
        },
        {
            "location": "/GettingStarted/#running-the-simulation",
            "text": "",
            "title": "Running the simulation"
        },
        {
            "location": "/GettingStarted/#things-to-watch-out-for",
            "text": "",
            "title": "Things to watch out for"
        },
        {
            "location": "/examples/UserCommands/",
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Controlling SimCADO"
        },
        {
            "location": "/examples/UserCommands/#welcome-to-mkdocs",
            "text": "For full documentation visit  mkdocs.org .",
            "title": "Welcome to MkDocs"
        },
        {
            "location": "/examples/UserCommands/#commands",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "Commands"
        },
        {
            "location": "/examples/UserCommands/#project-layout",
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Project layout"
        },
        {
            "location": "/examples/Source/",
            "text": "Examples with the \nSource\n object\n\n\nThe \nSource\n class is probably the most important class for testing science cases. Therefore spending time on creating accurate \nSource\n representations of the object of interest is key to getting good results with SimCADO.\n\n\nBasically a \nSource\n object represents photon sources using lists of positions (\n.x, .y\n), a list of unique spectra (\n.spectra\n) and a list of references which match each photon source to a spectrum in the list of spectra (\n.ref\n). All sources (extended and point source) can be decomposed into these lists. The advantage of using this approach is that objects with highly similar spectra can both reference the same position in \n.spectra\n, thereby reducing the number of spectra that need to be manipulated during a simulation. \n\n\nMy first \nSource\n\n\nTo begin with it is probably easiest to let SimCADO generate a \nSource\n object. The convenience function \nsimcado.source.star()\n will generate a \nSource\n object containing a single star. In this case, we'll choose an G2V star with a K-band magnitude of 20, placed 5 arcsec above the centre of the focal plane:\n\n\n>>> star_1 = simcado.source.star(mag=20, filter_name=\"K\", spec_type=\"G2V\", position=(5,0))\n\n\n\nstar_1\n the coordinates of the star are held in the arrays \n.x\n and \n.y\n, and the G2V spectrum in `.spectra\u00b4.\n\n\n>>> star_1.x[0], star_1.y[0]\n(5, 0)\n\n\n\nThe spectrum for \nstar_1\n is held in \n.spectra\n and the central wavelength of each of the spectral bins is in \n.lam\n. \n\n\n>>> star_1.lam, star_1.spectra[0]\n<insert output here>\n\n\n\nNote\n that \n.lam\n is a (1,n) array where as \n.spectra\n is a (m,n) array where n is the number of bins in the spectra and m is the number of unique spectra in the \nSource\n object. \n\n\nCombining \nSource\n objects\n\n\nBecause a \nSource\n object is just a collection of arrays, it is easy to add many together with the \n+\n operator:\n\n\n>>> star_2 = simcado.source.star(mag=22, filter_name=\"K\", spec_type=\"A0V\", position=(2,-2))\n>>> two_stars = star_1 + star_2\n>>> two_stars.x, two_stars.y\n((5, 2), (0, -2))\n\n\n\nNote\n this a very trivial example (for which SimCADO has a more elegant function: \nsimcado.source.stars()\n), but it serves to illustrate the main idea. The overloaded \n+\n operator is very useful for combining objects, e.g. forground stars and background galaxies, in order to get a better representation of the sky.\n\n\nPoint sources\n\n\nFor generating a field of stars, SimCADO offers a series of convenience functions. Please see the docstring or API documentation for more information on how best to use them.\n\n \nsimcado.source.star()\n\n\n \nsimcado.source.stars()\n\n\n \nsimcado.source.star_grid()\n\n\n \nsimcado.source.source_1E4_cluster()\n\n\nUsing an image as a template for a \nSource\n object\n\n\nIf we have an extended source that we wish to simulate, e.g. a galaxy, a nebula, etc. we can use the function \nsimcado.source.source_from_image()\n. The image must be a 2D \nnumpy.ndarray\n, but it can come from anywhere, e.g. a FITS file, generated my another function, or even a MS Paint bitmap image. \n\n\n>>> image_1 = astropy.io.fits.getdata(\"orion.fits\")\n>>> image_1\narray([[0.0, ... 0.0],\n       ... ,\n       [0.0, ... 0.0]])\n\n\n\nHere SimCADO takes a the pixel coordinates of the image and converts them to positions on the focal plane. \nNote\n the user must specify a plate-scale in arcseconds (\npix_res=\n) for the image. Each pixel with a value above a certain threshold (default \nflux_threshold=0\n) will be used in the \nSource\n object. The coordinates of these pixels are added to the arrays \n.x\n and \n.y\n. \n\n\nWe also need to provide a spectrum for the image. This spectrum is assumed to be the only spectrum for each pixel in the image. The pixel values are then the intensity assigned to that spectrum at that pixel position. \n\n\nSimCADO provides the pickles library for stellar spectra. Unfortunately there aren't any built-in galactic spectra yet - for this the user will need to provide their own spectrum.\n\n\n>>> lam, spec_1 = simcado.source.SED(\"G2V\", \"K\", magnitude=20)\n>>> lam, spec_1\n(array([0.7 ... 2.5]), array([0.0 ... 0.0]))\n\n\n\nWith \nimage_1\n, \nlam\n and \nspec_1\n we can now build a \nSource\n object for an orion-like nebula that has the spectrum of a sun-like star. \n\n\n>>> simcado.source.source_from_image(image_1, lam, spec_1, pix_res=0.004, flux_threshold=0)\n\n\n\nWhile this example is physically unrealistic, it serves the purpose of showing how to build a \nSource\n object from an image. The user is\n\n\nImages with multipe spectra\n\n\nIn reality assigning a single spectrum to an extended object is of limited use. For a \nSource\n to be realistic is should contain multiple spectra for objects in different locations. The best way to simulate this with SimCADO is to create a \nSource\n object for each unique group of objects (e.g. old stellar population, star forming regions, AGN, etc) and then combine them into a single \nSource\n object with the \n+\n operator.\n\n\nAs a worked example, lets create a \"first-order\" approximation to a star forming galaxy. The two major components of this source are \n1. the aged stellar population and,\n2. the star forming regions. \n\n\nIn our (very) crude model the aged stellar population can be approxiated by an ellipse with Gaussian light distribution. As M stars make up the majority of this population, we can assign a M0V spectrum to this population.\n\n\n>>> from astropy.convolution import Gaussian2DKernel\n>>> from simcado.source import SED\n>>> \n>>> old_pop = Gaussian2DKernel(128).array[::3,:]\n>>> m0v_spec = SED()\n\n\n\nFor the star forming regions we can create a random distribution of elliptical Gaussians\n\n\nMaking a \nSource\n object directly\n\n\nSimCADO convenience functions\n\n\n\n\nsimcado.source.stars()\n\n\nsimcado.source.source_1E4_cluster()\n\n\nsimcado.source.SED()\n\n\nsimcado.source.source_from_image()\n\n\nsimcado.source.Source()",
            "title": "Creating Sources"
        },
        {
            "location": "/examples/Source/#examples-with-the-source-object",
            "text": "The  Source  class is probably the most important class for testing science cases. Therefore spending time on creating accurate  Source  representations of the object of interest is key to getting good results with SimCADO.  Basically a  Source  object represents photon sources using lists of positions ( .x, .y ), a list of unique spectra ( .spectra ) and a list of references which match each photon source to a spectrum in the list of spectra ( .ref ). All sources (extended and point source) can be decomposed into these lists. The advantage of using this approach is that objects with highly similar spectra can both reference the same position in  .spectra , thereby reducing the number of spectra that need to be manipulated during a simulation.",
            "title": "Examples with the Source object"
        },
        {
            "location": "/examples/Source/#my-first-source",
            "text": "To begin with it is probably easiest to let SimCADO generate a  Source  object. The convenience function  simcado.source.star()  will generate a  Source  object containing a single star. In this case, we'll choose an G2V star with a K-band magnitude of 20, placed 5 arcsec above the centre of the focal plane:  >>> star_1 = simcado.source.star(mag=20, filter_name=\"K\", spec_type=\"G2V\", position=(5,0))  star_1  the coordinates of the star are held in the arrays  .x  and  .y , and the G2V spectrum in `.spectra\u00b4.  >>> star_1.x[0], star_1.y[0]\n(5, 0)  The spectrum for  star_1  is held in  .spectra  and the central wavelength of each of the spectral bins is in  .lam .   >>> star_1.lam, star_1.spectra[0]\n<insert output here>  Note  that  .lam  is a (1,n) array where as  .spectra  is a (m,n) array where n is the number of bins in the spectra and m is the number of unique spectra in the  Source  object.",
            "title": "My first Source"
        },
        {
            "location": "/examples/Source/#combining-source-objects",
            "text": "Because a  Source  object is just a collection of arrays, it is easy to add many together with the  +  operator:  >>> star_2 = simcado.source.star(mag=22, filter_name=\"K\", spec_type=\"A0V\", position=(2,-2))\n>>> two_stars = star_1 + star_2\n>>> two_stars.x, two_stars.y\n((5, 2), (0, -2))  Note  this a very trivial example (for which SimCADO has a more elegant function:  simcado.source.stars() ), but it serves to illustrate the main idea. The overloaded  +  operator is very useful for combining objects, e.g. forground stars and background galaxies, in order to get a better representation of the sky.",
            "title": "Combining Source objects"
        },
        {
            "location": "/examples/Source/#point-sources",
            "text": "For generating a field of stars, SimCADO offers a series of convenience functions. Please see the docstring or API documentation for more information on how best to use them.   simcado.source.star()    simcado.source.stars()    simcado.source.star_grid()    simcado.source.source_1E4_cluster()",
            "title": "Point sources"
        },
        {
            "location": "/examples/Source/#using-an-image-as-a-template-for-a-source-object",
            "text": "If we have an extended source that we wish to simulate, e.g. a galaxy, a nebula, etc. we can use the function  simcado.source.source_from_image() . The image must be a 2D  numpy.ndarray , but it can come from anywhere, e.g. a FITS file, generated my another function, or even a MS Paint bitmap image.   >>> image_1 = astropy.io.fits.getdata(\"orion.fits\")\n>>> image_1\narray([[0.0, ... 0.0],\n       ... ,\n       [0.0, ... 0.0]])  Here SimCADO takes a the pixel coordinates of the image and converts them to positions on the focal plane.  Note  the user must specify a plate-scale in arcseconds ( pix_res= ) for the image. Each pixel with a value above a certain threshold (default  flux_threshold=0 ) will be used in the  Source  object. The coordinates of these pixels are added to the arrays  .x  and  .y .   We also need to provide a spectrum for the image. This spectrum is assumed to be the only spectrum for each pixel in the image. The pixel values are then the intensity assigned to that spectrum at that pixel position.   SimCADO provides the pickles library for stellar spectra. Unfortunately there aren't any built-in galactic spectra yet - for this the user will need to provide their own spectrum.  >>> lam, spec_1 = simcado.source.SED(\"G2V\", \"K\", magnitude=20)\n>>> lam, spec_1\n(array([0.7 ... 2.5]), array([0.0 ... 0.0]))  With  image_1 ,  lam  and  spec_1  we can now build a  Source  object for an orion-like nebula that has the spectrum of a sun-like star.   >>> simcado.source.source_from_image(image_1, lam, spec_1, pix_res=0.004, flux_threshold=0)  While this example is physically unrealistic, it serves the purpose of showing how to build a  Source  object from an image. The user is",
            "title": "Using an image as a template for a Source object"
        },
        {
            "location": "/examples/Source/#images-with-multipe-spectra",
            "text": "In reality assigning a single spectrum to an extended object is of limited use. For a  Source  to be realistic is should contain multiple spectra for objects in different locations. The best way to simulate this with SimCADO is to create a  Source  object for each unique group of objects (e.g. old stellar population, star forming regions, AGN, etc) and then combine them into a single  Source  object with the  +  operator.  As a worked example, lets create a \"first-order\" approximation to a star forming galaxy. The two major components of this source are \n1. the aged stellar population and,\n2. the star forming regions.   In our (very) crude model the aged stellar population can be approxiated by an ellipse with Gaussian light distribution. As M stars make up the majority of this population, we can assign a M0V spectrum to this population.  >>> from astropy.convolution import Gaussian2DKernel\n>>> from simcado.source import SED\n>>> \n>>> old_pop = Gaussian2DKernel(128).array[::3,:]\n>>> m0v_spec = SED()  For the star forming regions we can create a random distribution of elliptical Gaussians",
            "title": "Images with multipe spectra"
        },
        {
            "location": "/examples/Source/#making-a-source-object-directly",
            "text": "",
            "title": "Making a Source object directly"
        },
        {
            "location": "/examples/Source/#simcado-convenience-functions",
            "text": "simcado.source.stars()  simcado.source.source_1E4_cluster()  simcado.source.SED()  simcado.source.source_from_image()  simcado.source.Source()",
            "title": "SimCADO convenience functions"
        },
        {
            "location": "/examples/OpticalTrain/",
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Manipulating the Optical Train"
        },
        {
            "location": "/examples/OpticalTrain/#welcome-to-mkdocs",
            "text": "For full documentation visit  mkdocs.org .",
            "title": "Welcome to MkDocs"
        },
        {
            "location": "/examples/OpticalTrain/#commands",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "Commands"
        },
        {
            "location": "/examples/OpticalTrain/#project-layout",
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Project layout"
        },
        {
            "location": "/examples/Detector/",
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Reading out the Detector"
        },
        {
            "location": "/examples/Detector/#welcome-to-mkdocs",
            "text": "For full documentation visit  mkdocs.org .",
            "title": "Welcome to MkDocs"
        },
        {
            "location": "/examples/Detector/#commands",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "Commands"
        },
        {
            "location": "/examples/Detector/#project-layout",
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Project layout"
        },
        {
            "location": "/Download/",
            "text": "Download\n\n\nSimCADO can be downloaded from this link \n\n\nhttp://homepage.univie.ac.at/kieran.leschinski/SimCADO/SimCADO-0.2dev.zip\n\n\nInstallation\n\n\n\u200b\nTo install it, download SimCADO from the link above and use the standard \npip\n call to install it\n\n\n$ pip install SimCADO-0.2dev.zip\n\n\nAlternatively give the full URL to pip and let it do the downloading for you\n\n\n$ pip install http://homepage.univie.ac.at/kieran.leschinski/SimCADO/SimCADO-0.2dev.zip\n\n\nDependencies\n\n\nNeeded:\n\n\n\n\nnumpy >1.10.4\n\n\nscipy >0.17\n\n\nastropy >1.1.2\n\n\n\n\nOptional (but recommended)\n\n\n\n\nmatplotlib\n\n\npoppy >0.4.0\n\u200b",
            "title": "Download"
        },
        {
            "location": "/Download/#download",
            "text": "SimCADO can be downloaded from this link   http://homepage.univie.ac.at/kieran.leschinski/SimCADO/SimCADO-0.2dev.zip",
            "title": "Download"
        },
        {
            "location": "/Download/#installation",
            "text": "\u200b\nTo install it, download SimCADO from the link above and use the standard  pip  call to install it  $ pip install SimCADO-0.2dev.zip  Alternatively give the full URL to pip and let it do the downloading for you  $ pip install http://homepage.univie.ac.at/kieran.leschinski/SimCADO/SimCADO-0.2dev.zip",
            "title": "Installation"
        },
        {
            "location": "/Download/#dependencies",
            "text": "",
            "title": "Dependencies"
        },
        {
            "location": "/Download/#needed",
            "text": "numpy >1.10.4  scipy >0.17  astropy >1.1.2",
            "title": "Needed:"
        },
        {
            "location": "/Download/#optional-but-recommended",
            "text": "matplotlib  poppy >0.4.0\n\u200b",
            "title": "Optional (but recommended)"
        },
        {
            "location": "/deep_stuff/SimCADO/",
            "text": "SimCADO objects\n\n\nSource\n\n\nThe \nSource\n class is probably the most important class for testing science cases. Therefore spending time on creating accurate \nSource\n representations of the object of interest is key to getting good results with SimCADO.\n\n\nBasically a \nSource\n object represents photon sources using lists of positions (\n.x, .y\n), a list of unique spectra (\n.spectra\n) and a list of references which match each photon source to a spectrum in the list of spectra (\n.ref\n). All sources (extended and point source) can be decomposed into these lists. The advantage of using this approach is that objects with highly similar spectra can both reference the same position in \n.spectra\n, thereby reducing the number of spectra that need to be manipulated during a simulation. \n\n\nFile Format of saved \nSource\n objects\n\n\nSource\n objects are stored as FITS files with 2 extensions. The first (ext=0) contains an image with dimensions (n, 4) where n is the number of positions for which there exists a spectrum - i.e. non-empty space. The 4 rows of the image correspond to the \n.x, .y, .ref, .weight\n arrays. The second extension (ext=1) contains another image with dimensions (m+1, len(lam)), where m is the number of unique spectra and len(lam) is the length of the \n.lam\n array containing the centres of all wavelength bins. The first row in the second extension is the \n.lam\n array.\n\n\nOpticalTrain\n\n\nDetector\n\n\nUserCommands\n\n\nSimCADO methods\n\n\nMethod behind applying an \nOpticalTrain\n to a \nSource\n object\n\n\n(Taken from Leschinski et al. 2016)\n\n\nIn an ideal world, SimCADO would apply all spectral and spatial changes at the resolution of the input data. However, the memory requirements to do this are well outside the limits of a personal computer. The solution to this problem is to split the effects based on dimensionality. For certain elements in the optical train, the spectral and spatial effects can be decoupled (e.g. purely transmissive elements like the filters versus purely spatial effects like telescope vibration). For other elements, most notably the PSF and ADC, all three dimensions must be considered simultaneously. When applying an  \nOpticalTrain\n, SimCADO follows the procedure described graphically in Figure 1. The example used in Figure 1 is for a simplified stellar cluster with only two different stellar types - A0V and K5V type stars. \n\n\n\n\nFigure 1 - The steps involved in applying an \nOpticalTrain\n object to a \nSource\n object. The example used here is for a simplified stellar cluster with only two different stellar types - A0V and K5V type stars.\n\n\n\n\n\n\nA.\n The original \nSource\n object includes an array of spectra for each \nunique\n photon source (in the case of Figure 1, there are only two unique spectra) and four vectors: \nx\n, \ny\n, \nref\n, \nweight\n. \nx\n and \ny\n hold the spatial information for each photon source, \nref\n connects each source to a spectrum in the array of spectra and \nweight\n allows the spectrum to be scaled. \n\n\n\n\n\n\nSpectral-effects\n. The first step in \napply_optical_train()\n is to combine all optical elements which only act in the wavelength domain (e.g. filters, mirrors, etc.) into a single effect, then apply that effect to the array of spectra in the \nSource\n object. \n\n\n\n\n\n\nB.\n The spectra in the \nSource\n object are now representative of the photo-electron count at the detector, assuming a perfect optical train and at the internal spatial resolution of the simulation, i.e. \nnot at the pixel scale of the detector\n. The position vectors are converted into a two-dimensional \"image\" of the \nSource\n.\n\n\n\n\n\n\nSpectrospatial-effects.\n The second step includes creating \"slices\" through the data. The spectra are binned according to several criteria (ADC shift, PSF FWHM difference, etc) with a spectral resolution anywhere from R=1 to R>100, and the number of photons per source in each wavelength bin is calculated. The sources in each \"slice\" are scaled according to the number of photons in each bin. The relevant spatial effects (atmospheric dispersion, convolution with PSF kernel, etc.) are then applied to each slice in turn.\n\n\n\n\n\n\nC.\n At this stage, the \nSource\n object contains many spectral slices. Each is essentially the equivalent of a (\nvery\n) narrow-band filter image.\n\n\n\n\n\n\nD.\n All spectral effects have been taken into account, and so the binning in the spectral domain is no longer needed. The third step in \napply_optical_train()\n is to add all the slices together to create a single monochrome image.\n\n\n\n\n\n\nSpatial-effects.\n Fourth in the series of operations is to apply the purely spatial effects (e.g. telescope jitter, field rotation, etc) to the monochrome image. \n\n\n\n\n\n\nE.\n The resulting image represents how the incoming photons from the source would be distributed on the focal plane after travelling through the entire optical train. At this point the background photons are also added to the image. Because SimCADO doesn't take into account the changing sky background, the sky emission is approximated as a constant background photon count determined from an atmospheric emission curve (either provided by the user or generated by \nSkyCalc\n [Noll et al. 2012, Jones et al. 2013]). The mirror blackbody emission is also approximated as spatially constant. For all filters, with the exception of K, the amount of additional photons due to the mirror is close to negligible.\n\n\n\n\n\n\nDetector-effects.\n The image is resampled down from the internally oversampled grid down to the pixel scale of the detector chips - in the case of MICADO either 4 mas or 1.5 mas, depending on mode. The final step is to add noise in all its forms to the image. Various aspects of the detector noise (correlated and uncorrelated white and pink noise read-out (see Rauscher 2015), dead pixels, etc.), as well as photon shot noise for both the atmospheric and object photons are taken into account. Further effects (e.g. detector persistence, cross-talk, etc) are also added to the image at this point.\n\n\n\n\n\n\nF.\n The final image represents the spatial distribution of all photo-electrons (from the source object + atmosphere + primary mirror) plus the electronic noise generated by reading out the detector chips. The images from all the chips considered in a simulation are packed into a FITS extension and the FITS file is either written out to disk, or returned to the user if generated during an interactive Python session.\n\n\n\n\n\n\nMethod behind reading out a \nDetector\n object",
            "title": "How SimCADO works"
        },
        {
            "location": "/deep_stuff/SimCADO/#simcado-objects",
            "text": "",
            "title": "SimCADO objects"
        },
        {
            "location": "/deep_stuff/SimCADO/#source",
            "text": "The  Source  class is probably the most important class for testing science cases. Therefore spending time on creating accurate  Source  representations of the object of interest is key to getting good results with SimCADO.  Basically a  Source  object represents photon sources using lists of positions ( .x, .y ), a list of unique spectra ( .spectra ) and a list of references which match each photon source to a spectrum in the list of spectra ( .ref ). All sources (extended and point source) can be decomposed into these lists. The advantage of using this approach is that objects with highly similar spectra can both reference the same position in  .spectra , thereby reducing the number of spectra that need to be manipulated during a simulation.",
            "title": "Source"
        },
        {
            "location": "/deep_stuff/SimCADO/#file-format-of-saved-source-objects",
            "text": "Source  objects are stored as FITS files with 2 extensions. The first (ext=0) contains an image with dimensions (n, 4) where n is the number of positions for which there exists a spectrum - i.e. non-empty space. The 4 rows of the image correspond to the  .x, .y, .ref, .weight  arrays. The second extension (ext=1) contains another image with dimensions (m+1, len(lam)), where m is the number of unique spectra and len(lam) is the length of the  .lam  array containing the centres of all wavelength bins. The first row in the second extension is the  .lam  array.",
            "title": "File Format of saved Source objects"
        },
        {
            "location": "/deep_stuff/SimCADO/#opticaltrain",
            "text": "",
            "title": "OpticalTrain"
        },
        {
            "location": "/deep_stuff/SimCADO/#detector",
            "text": "",
            "title": "Detector"
        },
        {
            "location": "/deep_stuff/SimCADO/#usercommands",
            "text": "",
            "title": "UserCommands"
        },
        {
            "location": "/deep_stuff/SimCADO/#simcado-methods",
            "text": "",
            "title": "SimCADO methods"
        },
        {
            "location": "/deep_stuff/SimCADO/#method-behind-applying-an-opticaltrain-to-a-source-object",
            "text": "(Taken from Leschinski et al. 2016)  In an ideal world, SimCADO would apply all spectral and spatial changes at the resolution of the input data. However, the memory requirements to do this are well outside the limits of a personal computer. The solution to this problem is to split the effects based on dimensionality. For certain elements in the optical train, the spectral and spatial effects can be decoupled (e.g. purely transmissive elements like the filters versus purely spatial effects like telescope vibration). For other elements, most notably the PSF and ADC, all three dimensions must be considered simultaneously. When applying an   OpticalTrain , SimCADO follows the procedure described graphically in Figure 1. The example used in Figure 1 is for a simplified stellar cluster with only two different stellar types - A0V and K5V type stars.    Figure 1 - The steps involved in applying an  OpticalTrain  object to a  Source  object. The example used here is for a simplified stellar cluster with only two different stellar types - A0V and K5V type stars.    A.  The original  Source  object includes an array of spectra for each  unique  photon source (in the case of Figure 1, there are only two unique spectra) and four vectors:  x ,  y ,  ref ,  weight .  x  and  y  hold the spatial information for each photon source,  ref  connects each source to a spectrum in the array of spectra and  weight  allows the spectrum to be scaled.     Spectral-effects . The first step in  apply_optical_train()  is to combine all optical elements which only act in the wavelength domain (e.g. filters, mirrors, etc.) into a single effect, then apply that effect to the array of spectra in the  Source  object.     B.  The spectra in the  Source  object are now representative of the photo-electron count at the detector, assuming a perfect optical train and at the internal spatial resolution of the simulation, i.e.  not at the pixel scale of the detector . The position vectors are converted into a two-dimensional \"image\" of the  Source .    Spectrospatial-effects.  The second step includes creating \"slices\" through the data. The spectra are binned according to several criteria (ADC shift, PSF FWHM difference, etc) with a spectral resolution anywhere from R=1 to R>100, and the number of photons per source in each wavelength bin is calculated. The sources in each \"slice\" are scaled according to the number of photons in each bin. The relevant spatial effects (atmospheric dispersion, convolution with PSF kernel, etc.) are then applied to each slice in turn.    C.  At this stage, the  Source  object contains many spectral slices. Each is essentially the equivalent of a ( very ) narrow-band filter image.    D.  All spectral effects have been taken into account, and so the binning in the spectral domain is no longer needed. The third step in  apply_optical_train()  is to add all the slices together to create a single monochrome image.    Spatial-effects.  Fourth in the series of operations is to apply the purely spatial effects (e.g. telescope jitter, field rotation, etc) to the monochrome image.     E.  The resulting image represents how the incoming photons from the source would be distributed on the focal plane after travelling through the entire optical train. At this point the background photons are also added to the image. Because SimCADO doesn't take into account the changing sky background, the sky emission is approximated as a constant background photon count determined from an atmospheric emission curve (either provided by the user or generated by  SkyCalc  [Noll et al. 2012, Jones et al. 2013]). The mirror blackbody emission is also approximated as spatially constant. For all filters, with the exception of K, the amount of additional photons due to the mirror is close to negligible.    Detector-effects.  The image is resampled down from the internally oversampled grid down to the pixel scale of the detector chips - in the case of MICADO either 4 mas or 1.5 mas, depending on mode. The final step is to add noise in all its forms to the image. Various aspects of the detector noise (correlated and uncorrelated white and pink noise read-out (see Rauscher 2015), dead pixels, etc.), as well as photon shot noise for both the atmospheric and object photons are taken into account. Further effects (e.g. detector persistence, cross-talk, etc) are also added to the image at this point.    F.  The final image represents the spatial distribution of all photo-electrons (from the source object + atmosphere + primary mirror) plus the electronic noise generated by reading out the detector chips. The images from all the chips considered in a simulation are packed into a FITS extension and the FITS file is either written out to disk, or returned to the user if generated during an interactive Python session.",
            "title": "Method behind applying an OpticalTrain to a Source object"
        },
        {
            "location": "/deep_stuff/SimCADO/#method-behind-reading-out-a-detector-object",
            "text": "",
            "title": "Method behind reading out a Detector object"
        },
        {
            "location": "/deep_stuff/Testing/",
            "text": "SimCADO FAQs\n\n\nWhat is SimCADO?\n\n\nWhat SimCADO can do?\n\n\nWhat SimCADO can't yet do?\n\n\nWhat SimCADO will never do?\n\n\nI have useful instrument data, who do I give it to?",
            "title": "Testing SimCADO"
        },
        {
            "location": "/deep_stuff/Testing/#simcado-faqs",
            "text": "",
            "title": "SimCADO FAQs"
        },
        {
            "location": "/deep_stuff/Testing/#what-is-simcado",
            "text": "",
            "title": "What is SimCADO?"
        },
        {
            "location": "/deep_stuff/Testing/#what-simcado-can-do",
            "text": "",
            "title": "What SimCADO can do?"
        },
        {
            "location": "/deep_stuff/Testing/#what-simcado-cant-yet-do",
            "text": "",
            "title": "What SimCADO can't yet do?"
        },
        {
            "location": "/deep_stuff/Testing/#what-simcado-will-never-do",
            "text": "",
            "title": "What SimCADO will never do?"
        },
        {
            "location": "/deep_stuff/Testing/#i-have-useful-instrument-data-who-do-i-give-it-to",
            "text": "",
            "title": "I have useful instrument data, who do I give it to?"
        },
        {
            "location": "/deep_stuff/FAQs/",
            "text": "SimCADO FAQs\n\n\nWhat SimCADO can do?\n\n\nWhat SimCADO can't yet do?\n\n\nWhat SimCADO will never do?\n\n\nI have useful instrument data, who do I give it to?",
            "title": "FAQs"
        },
        {
            "location": "/deep_stuff/FAQs/#simcado-faqs",
            "text": "",
            "title": "SimCADO FAQs"
        },
        {
            "location": "/deep_stuff/FAQs/#what-simcado-can-do",
            "text": "",
            "title": "What SimCADO can do?"
        },
        {
            "location": "/deep_stuff/FAQs/#what-simcado-cant-yet-do",
            "text": "",
            "title": "What SimCADO can't yet do?"
        },
        {
            "location": "/deep_stuff/FAQs/#what-simcado-will-never-do",
            "text": "",
            "title": "What SimCADO will never do?"
        },
        {
            "location": "/deep_stuff/FAQs/#i-have-useful-instrument-data-who-do-i-give-it-to",
            "text": "",
            "title": "I have useful instrument data, who do I give it to?"
        },
        {
            "location": "/Keywords/",
            "text": "List of Keywords for Controlling SimCADO\n\n\nParameters regarding the simulated \"observation\"\n\n\nKeyword             Default Value     [units] Explanation\n-----------------------------------------------------------------------------------------------\nOBS_DATE                0           # [dd/mm/yyyy] Date of the observation [not yet implemented]\nOBS_TIME                0           # [hh:mm:ss] Time of the observation [not yet implemented]\nOBS_RA                  0           # [deg] RA of the object [not yet implemented]\nOBS_DEC                 0           # [deg] Dec of the object [not yet implemented]\nOBS_ALT                 0           # [deg] Altitude of the object [not yet implemented]\nOBS_AZ                  0           # [deg] Azimuth of the object [not yet implemented]\nOBS_ZENITH_DIST         60          # [deg] from zenith\nOBS_PARALLACTIC_ANGLE   0           # [deg] rotation of the source relative to the zenith\nOBS_SEEING              0.6         # [arcsec]\n\nOBS_EXPTIME             60          # [sec] simulated exposure time\nOBS_NDIT                1           # [#] number of exposures taken\nOBS_NONDESTRUCT_TRO     2.6         # [sec] time between non-destructive readouts in the detector\nOBS_REMOVE_CONST_BG     yes         # remove the minimum background value\n\nOBS_INPUT_SOURCE_PATH   none        # Path to input Source FITS file\nOBS_FITS_EXT            0           # the extension number where the useful data cube is\n\nOBS_OUTPUT_DIR          default     # Path to save output in\n\nOBS_OUT_SIGNAL          yes         # yes/no to saving the signal component of the observation\nOBS_OUT_NOISE           yes         # yes/no to saving the noise component of the observation\nOBS_OUT_READOUT         yes         # yes/no to saving the readout component of the observation\nOBS_OUT_REDUCED         yes         # yes/no to saving a background subtracted readout image\n\n\n\n\nParameters relating to the simulation\n\n\nKeyword             Default Value     [units] Explanation\n-----------------------------------------------------------------------------------------------\nSIM_DETECTOR_PIX_SCALE  0.004       # [arcsec] plate scale of the detector\nSIM_OVERSAMPLING        1           # The factor of oversampling inside the simulation\nSIM_PIXEL_THRESHOLD     1           # photons per pixel summed over the wavelength range. Values less than this are assumed to be zero\n\nSIM_LAM_TC_BIN_WIDTH    0.001       # [um] wavelength resolution of spectral curves\nSIM_SPEC_MIN_STEP       1E-4        # [um] minimum step size where resampling spectral curves\n\nSIM_FILTER_THRESHOLD    1E-9        # transmission below this threshold is assumed to be 0\nSIM_USE_FILTER_LAM      yes         # yes/no to basing the wavelength range off the filter non-zero range - if no, specify LAM_MIN, LAM_MAX\n# if \"no\"\nSIM_LAM_MIN             1.9         # [um] lower wavelength range of observation\nSIM_LAM_MAX             2.41        # [um] upper wavelength range of observation\nSIM_LAM_PSF_BIN_WIDTH   0.1         # [um] wavelength resolution of the PSF layers\nSIM_ADC_SHIFT_THRESHOLD 1           # [pixel] the spatial shift before a new spectral layer is added (i.e. how often the spectral domain is sampled for an under-performing ADC)\n\nSIM_PSF_SIZE            511         # size of PSF\nSIM_PSF_OVERSAMPLE      no          # use astropy's inbuilt oversampling technique when generating the PSFs. Kills memory for PSFs over 511 x 511\nSIM_VERBOSE             no          # [yes/no] print information on the simulation run\nSIM_SIM_MESSAGE_LEVEL   3           # the amount of information printed [5-everything, 0-nothing]\n\nSIM_OPT_TRAIN_IN_PATH   none        # Options for saving and reusing optical trains. If \"none\": \"./\"\nSIM_OPT_TRAIN_OUT_PATH  none        # Options for saving and reusing optical trains. If \"none\": \"./\"\nSIM_DETECTOR_IN_PATH   none        # Options for saving and reusing detector objects. If \"none\": \"./\"\nSIM_DETECTOR_OUT_PATH  none        # Options for saving and reusing detector objects. If \"none\": \"./\"\n\nSIM_MAX_RAM_CHUNK_GB   2            # Maximum amount of RAM to be taken up by one a single object\nSIM_SPEED              10           # 10 = Fast, but skips on details, 1 = Slow, but does everything as accurately as possible\nSIM_NUM_CPUS           -1           # Number of CPUs to use for multicore computations. -1 = all idyl cores\n\n\n\n\nGeneral atmospheric parameters\n\n\nKeyword             Default Value     [units] Explanation\n-----------------------------------------------------------------------------------------------\nATMO_USE_ATMO_BG       yes          # [yes/no] \n\nATMO_TC                 default     # [filename/default] for atmospheric transmission curve. If \"default\": <pkg_dir>/data/skytable.fits\nATMO_EC                 default     # [filename/default/none] for atmospheric emission curve. If \"default\": <pkg_dir>/data/skytable.fits\n# If ATMO_EC is \"none\": set ATMO_BG_MAGNITUDE for the simulation filter. \nATMO_BG_MAGNITUDE       default     # [ph/s] background photons for the bandpass if ATMO_EC = None\n\nATMO_TEMPERATURE        0           # deg Celcius\nATMO_PRESSURE           750         # millibar\nATMO_REL_HUMIDITY       60          # %\n\n\n\n\nGeneral Telescope parameters\n\n\nKeyword             Default Value     [units] Explanation\n-----------------------------------------------------------------------------------------------\nSCOPE_ALTITUDE          3060        # meters above sea level\nSCOPE_LATITUDE          -24.589167  # decimal degrees\nSCOPE_LONGITUDE         -70.192222  # decimal degrees\n\nSCOPE_PSF_FILE          default      # [filename/default] import a PSF from a file, if none \"default\" is <pkg_dir>/data/PSF_POPPY.fits\nSCOPE_STREHL_RATIO      1         # [0..1] defines the strength of the seeing halo if SCOPE_PSF_FILE is \"default\"\nSCOPE_AO_EFFECTIVENESS  100         # [%] percentage of seeing PSF corrected by AO - 100% = diff limited, 0% = 0.8\" seeing\nSCOPE_JITTER_FWHM       0.001       # [arcsec] gaussian telescope jitter (wind, tracking)\nSCOPE_DRIFT_DISTANCE    0           # [arcsec/sec] the drift in tracking by the telescope\nSCOPE_DRIFT_PROFILE     linear      # [linear, gaussian] the drift profile. If linear, simulates when tracking is off. If gaussian, simulates rms distance of tracking errors\n\nSCOPE_USE_MIRROR_BG     yes         # [yes/no]\n\n# Similar details can be specified for each individual mirror by copying these\n# keywords and replacing M1 with Mx. Properties not explicitly specified are\n# inherited from M1.\nSCOPE_NUM_MIRRORS       6           # number of reflecting surfaces\nSCOPE_M1_DIAMETER_OUT   37.3        # meters\nSCOPE_M1_DIAMETER_IN    11.1        # meters\nSCOPE_M1_TC             default        # Mirror reflectance curve. Default is <pkg_dir>/data/TC_mirror_mgf2agal.dat\nSCOPE_M1_TEMP           0           # deg Celsius - temperature of mirror\nSCOPE_M2_DIAMETER_OUT   4.2         # meters\nSCOPE_M2_DIAMETER_IN    0.          # meters\nSCOPE_M3_DIAMETER_OUT   3.8         # meters\nSCOPE_M3_DIAMETER_IN    0.          # meters\n\n\n\n\nParameters regarding the instrument\n\n\nKeyword             Default Value     [units] Explanation\n-----------------------------------------------------------------------------------------------\nINST_TEMPERATURE        -190        # deg Celsius - inside temp of instrument\n\nINST_ENTR_NUM_SURFACES  2           # number of surfaces on the entrance window\nINST_ENTR_WINDOW_TC     default     # If \"default\": <pkg_dir>/data/TC_window.dat\nINST_DICHROIC_TC        default\nINST_FILTER_TC          K          # specify a standard broadband filter of a file path to a transmission curve. Accepted broadband filters: I z Y J H Ks K\n\nINST_NUM_MIRRORS        8           # number of reflecting surfaces in MICADO\nINST_NUM_EXT_MIRRORS    8           # number of reflecting surfaces between telescope and instrument (i.e. MAORY)\n\nINST_ADC_PERFORMANCE    100         # [%] how well the ADC does its job\nINST_ADC_NUM_SURFACES   4           # number of surfaces in the ADC\nINST_ADC_TC             default     # transmission curve of the ADC. If \"default\": <pkg_dir>/data/\n\nINST_DEROT_PERFORMANCE  100         # [%] how well the derotator derotates\nINST_DEROT_PROFILE      linear      # [linear, gaussian] the profile with which it does it's job\n\nINST_DISTORTION_MAP     none        # path to distortion map\n\n\n\n\nGeneral detector parameters\n\n\nKeyword             Default Value     [units] Explanation\n-----------------------------------------------------------------------------------------------\nFPA_USE_NOISE           yes         # [yes/no]\n\nFPA_READOUT_MEDIAN      4           # e-/px\nFPA_READOUT_STDEV       1           # e-/px\nFPA_DARK_MEDIAN         0.01        # e-/s/px\nFPA_DARK_STDEV          0.01        # e-/s/px\n\nFPA_QE                  default     # if \"default\": <package_path>/data/TC_detector_H4RG.dat\nFPA_NOISE_PATH          default     # [default/generate/filename] if \"generate\": use NGHxRG to create a noise frame. If \"default\": <package_path>/data/FPA_noise.fits\nFPA_GAIN                1           # e- to ADU conversion\nFPA_WELL_DEPTH          1E5         # number of photons collectable before pixel is full\nFPA_LINEARITY_CURVE     none        #\n\nFPA_PIXEL_MAP           none        # path to a FITS file with the pixel sensitivity map\n# if none\nFPA_DEAD_PIXELS         1           # [%] if FPA_PIXEL_MAP=none, a percentage of detector pixel which are dead\nFPA_DEAD_LINES          1           # [%] if FPA_PIXEL_MAP=none, a percentage of detector lines which are dead\n\nFPA_CHIP_LAYOUT         small       # [small/default/filename] description of the chip layout on the detector array. if \"default\": <pkg_dir>/data/FPA_chip_layout.dat\n\n\n\n\nNXRG Noise Generator package parameters\n\n\nSimCADO uses the python code developed by Bernhard Rauscher for the HAWAII 2RG detectors aboard the JWST. See Rauscher (2015) for a summary of what keqwords they mean (\nhttp://arxiv.org/pdf/1509.06264.pdf\n)\n\n\nKeyword             Default Value     [units] Explanation\n-----------------------------------------------------------------------------------------------\n\nHXRG_NUM_OUTPUTS        32          # Number of\nHXRG_NUM_ROW_OH         8           # Number of row overheads\nHXRG_PCA0_FILENAME      default     # if \"default\": <pkg_dir>/data/FPA_nirspec_pca0.fits\nHXRG_OUTPUT_PATH        none        # Path to save the detector noise\nHXRG_PEDESTAL           4           # Pedestal noise\nHXRG_CORR_PINK          3           # Correlated Pink noise\nHXRG_UNCORR_PINK        1           # Uncorrelated Pink noise\nHXRG_ALT_COL_NOISE      0.5         # Alternating Column noise",
            "title": "List of Control Keywords"
        },
        {
            "location": "/Keywords/#list-of-keywords-for-controlling-simcado",
            "text": "",
            "title": "List of Keywords for Controlling SimCADO"
        },
        {
            "location": "/Keywords/#parameters-regarding-the-simulated-observation",
            "text": "Keyword             Default Value     [units] Explanation\n-----------------------------------------------------------------------------------------------\nOBS_DATE                0           # [dd/mm/yyyy] Date of the observation [not yet implemented]\nOBS_TIME                0           # [hh:mm:ss] Time of the observation [not yet implemented]\nOBS_RA                  0           # [deg] RA of the object [not yet implemented]\nOBS_DEC                 0           # [deg] Dec of the object [not yet implemented]\nOBS_ALT                 0           # [deg] Altitude of the object [not yet implemented]\nOBS_AZ                  0           # [deg] Azimuth of the object [not yet implemented]\nOBS_ZENITH_DIST         60          # [deg] from zenith\nOBS_PARALLACTIC_ANGLE   0           # [deg] rotation of the source relative to the zenith\nOBS_SEEING              0.6         # [arcsec]\n\nOBS_EXPTIME             60          # [sec] simulated exposure time\nOBS_NDIT                1           # [#] number of exposures taken\nOBS_NONDESTRUCT_TRO     2.6         # [sec] time between non-destructive readouts in the detector\nOBS_REMOVE_CONST_BG     yes         # remove the minimum background value\n\nOBS_INPUT_SOURCE_PATH   none        # Path to input Source FITS file\nOBS_FITS_EXT            0           # the extension number where the useful data cube is\n\nOBS_OUTPUT_DIR          default     # Path to save output in\n\nOBS_OUT_SIGNAL          yes         # yes/no to saving the signal component of the observation\nOBS_OUT_NOISE           yes         # yes/no to saving the noise component of the observation\nOBS_OUT_READOUT         yes         # yes/no to saving the readout component of the observation\nOBS_OUT_REDUCED         yes         # yes/no to saving a background subtracted readout image",
            "title": "Parameters regarding the simulated \"observation\""
        },
        {
            "location": "/Keywords/#parameters-relating-to-the-simulation",
            "text": "Keyword             Default Value     [units] Explanation\n-----------------------------------------------------------------------------------------------\nSIM_DETECTOR_PIX_SCALE  0.004       # [arcsec] plate scale of the detector\nSIM_OVERSAMPLING        1           # The factor of oversampling inside the simulation\nSIM_PIXEL_THRESHOLD     1           # photons per pixel summed over the wavelength range. Values less than this are assumed to be zero\n\nSIM_LAM_TC_BIN_WIDTH    0.001       # [um] wavelength resolution of spectral curves\nSIM_SPEC_MIN_STEP       1E-4        # [um] minimum step size where resampling spectral curves\n\nSIM_FILTER_THRESHOLD    1E-9        # transmission below this threshold is assumed to be 0\nSIM_USE_FILTER_LAM      yes         # yes/no to basing the wavelength range off the filter non-zero range - if no, specify LAM_MIN, LAM_MAX\n# if \"no\"\nSIM_LAM_MIN             1.9         # [um] lower wavelength range of observation\nSIM_LAM_MAX             2.41        # [um] upper wavelength range of observation\nSIM_LAM_PSF_BIN_WIDTH   0.1         # [um] wavelength resolution of the PSF layers\nSIM_ADC_SHIFT_THRESHOLD 1           # [pixel] the spatial shift before a new spectral layer is added (i.e. how often the spectral domain is sampled for an under-performing ADC)\n\nSIM_PSF_SIZE            511         # size of PSF\nSIM_PSF_OVERSAMPLE      no          # use astropy's inbuilt oversampling technique when generating the PSFs. Kills memory for PSFs over 511 x 511\nSIM_VERBOSE             no          # [yes/no] print information on the simulation run\nSIM_SIM_MESSAGE_LEVEL   3           # the amount of information printed [5-everything, 0-nothing]\n\nSIM_OPT_TRAIN_IN_PATH   none        # Options for saving and reusing optical trains. If \"none\": \"./\"\nSIM_OPT_TRAIN_OUT_PATH  none        # Options for saving and reusing optical trains. If \"none\": \"./\"\nSIM_DETECTOR_IN_PATH   none        # Options for saving and reusing detector objects. If \"none\": \"./\"\nSIM_DETECTOR_OUT_PATH  none        # Options for saving and reusing detector objects. If \"none\": \"./\"\n\nSIM_MAX_RAM_CHUNK_GB   2            # Maximum amount of RAM to be taken up by one a single object\nSIM_SPEED              10           # 10 = Fast, but skips on details, 1 = Slow, but does everything as accurately as possible\nSIM_NUM_CPUS           -1           # Number of CPUs to use for multicore computations. -1 = all idyl cores",
            "title": "Parameters relating to the simulation"
        },
        {
            "location": "/Keywords/#general-atmospheric-parameters",
            "text": "Keyword             Default Value     [units] Explanation\n-----------------------------------------------------------------------------------------------\nATMO_USE_ATMO_BG       yes          # [yes/no] \n\nATMO_TC                 default     # [filename/default] for atmospheric transmission curve. If \"default\": <pkg_dir>/data/skytable.fits\nATMO_EC                 default     # [filename/default/none] for atmospheric emission curve. If \"default\": <pkg_dir>/data/skytable.fits\n# If ATMO_EC is \"none\": set ATMO_BG_MAGNITUDE for the simulation filter. \nATMO_BG_MAGNITUDE       default     # [ph/s] background photons for the bandpass if ATMO_EC = None\n\nATMO_TEMPERATURE        0           # deg Celcius\nATMO_PRESSURE           750         # millibar\nATMO_REL_HUMIDITY       60          # %",
            "title": "General atmospheric parameters"
        },
        {
            "location": "/Keywords/#general-telescope-parameters",
            "text": "Keyword             Default Value     [units] Explanation\n-----------------------------------------------------------------------------------------------\nSCOPE_ALTITUDE          3060        # meters above sea level\nSCOPE_LATITUDE          -24.589167  # decimal degrees\nSCOPE_LONGITUDE         -70.192222  # decimal degrees\n\nSCOPE_PSF_FILE          default      # [filename/default] import a PSF from a file, if none \"default\" is <pkg_dir>/data/PSF_POPPY.fits\nSCOPE_STREHL_RATIO      1         # [0..1] defines the strength of the seeing halo if SCOPE_PSF_FILE is \"default\"\nSCOPE_AO_EFFECTIVENESS  100         # [%] percentage of seeing PSF corrected by AO - 100% = diff limited, 0% = 0.8\" seeing\nSCOPE_JITTER_FWHM       0.001       # [arcsec] gaussian telescope jitter (wind, tracking)\nSCOPE_DRIFT_DISTANCE    0           # [arcsec/sec] the drift in tracking by the telescope\nSCOPE_DRIFT_PROFILE     linear      # [linear, gaussian] the drift profile. If linear, simulates when tracking is off. If gaussian, simulates rms distance of tracking errors\n\nSCOPE_USE_MIRROR_BG     yes         # [yes/no]\n\n# Similar details can be specified for each individual mirror by copying these\n# keywords and replacing M1 with Mx. Properties not explicitly specified are\n# inherited from M1.\nSCOPE_NUM_MIRRORS       6           # number of reflecting surfaces\nSCOPE_M1_DIAMETER_OUT   37.3        # meters\nSCOPE_M1_DIAMETER_IN    11.1        # meters\nSCOPE_M1_TC             default        # Mirror reflectance curve. Default is <pkg_dir>/data/TC_mirror_mgf2agal.dat\nSCOPE_M1_TEMP           0           # deg Celsius - temperature of mirror\nSCOPE_M2_DIAMETER_OUT   4.2         # meters\nSCOPE_M2_DIAMETER_IN    0.          # meters\nSCOPE_M3_DIAMETER_OUT   3.8         # meters\nSCOPE_M3_DIAMETER_IN    0.          # meters",
            "title": "General Telescope parameters"
        },
        {
            "location": "/Keywords/#parameters-regarding-the-instrument",
            "text": "Keyword             Default Value     [units] Explanation\n-----------------------------------------------------------------------------------------------\nINST_TEMPERATURE        -190        # deg Celsius - inside temp of instrument\n\nINST_ENTR_NUM_SURFACES  2           # number of surfaces on the entrance window\nINST_ENTR_WINDOW_TC     default     # If \"default\": <pkg_dir>/data/TC_window.dat\nINST_DICHROIC_TC        default\nINST_FILTER_TC          K          # specify a standard broadband filter of a file path to a transmission curve. Accepted broadband filters: I z Y J H Ks K\n\nINST_NUM_MIRRORS        8           # number of reflecting surfaces in MICADO\nINST_NUM_EXT_MIRRORS    8           # number of reflecting surfaces between telescope and instrument (i.e. MAORY)\n\nINST_ADC_PERFORMANCE    100         # [%] how well the ADC does its job\nINST_ADC_NUM_SURFACES   4           # number of surfaces in the ADC\nINST_ADC_TC             default     # transmission curve of the ADC. If \"default\": <pkg_dir>/data/\n\nINST_DEROT_PERFORMANCE  100         # [%] how well the derotator derotates\nINST_DEROT_PROFILE      linear      # [linear, gaussian] the profile with which it does it's job\n\nINST_DISTORTION_MAP     none        # path to distortion map",
            "title": "Parameters regarding the instrument"
        },
        {
            "location": "/Keywords/#general-detector-parameters",
            "text": "Keyword             Default Value     [units] Explanation\n-----------------------------------------------------------------------------------------------\nFPA_USE_NOISE           yes         # [yes/no]\n\nFPA_READOUT_MEDIAN      4           # e-/px\nFPA_READOUT_STDEV       1           # e-/px\nFPA_DARK_MEDIAN         0.01        # e-/s/px\nFPA_DARK_STDEV          0.01        # e-/s/px\n\nFPA_QE                  default     # if \"default\": <package_path>/data/TC_detector_H4RG.dat\nFPA_NOISE_PATH          default     # [default/generate/filename] if \"generate\": use NGHxRG to create a noise frame. If \"default\": <package_path>/data/FPA_noise.fits\nFPA_GAIN                1           # e- to ADU conversion\nFPA_WELL_DEPTH          1E5         # number of photons collectable before pixel is full\nFPA_LINEARITY_CURVE     none        #\n\nFPA_PIXEL_MAP           none        # path to a FITS file with the pixel sensitivity map\n# if none\nFPA_DEAD_PIXELS         1           # [%] if FPA_PIXEL_MAP=none, a percentage of detector pixel which are dead\nFPA_DEAD_LINES          1           # [%] if FPA_PIXEL_MAP=none, a percentage of detector lines which are dead\n\nFPA_CHIP_LAYOUT         small       # [small/default/filename] description of the chip layout on the detector array. if \"default\": <pkg_dir>/data/FPA_chip_layout.dat",
            "title": "General detector parameters"
        },
        {
            "location": "/Keywords/#nxrg-noise-generator-package-parameters",
            "text": "SimCADO uses the python code developed by Bernhard Rauscher for the HAWAII 2RG detectors aboard the JWST. See Rauscher (2015) for a summary of what keqwords they mean ( http://arxiv.org/pdf/1509.06264.pdf )  Keyword             Default Value     [units] Explanation\n-----------------------------------------------------------------------------------------------\n\nHXRG_NUM_OUTPUTS        32          # Number of\nHXRG_NUM_ROW_OH         8           # Number of row overheads\nHXRG_PCA0_FILENAME      default     # if \"default\": <pkg_dir>/data/FPA_nirspec_pca0.fits\nHXRG_OUTPUT_PATH        none        # Path to save the detector noise\nHXRG_PEDESTAL           4           # Pedestal noise\nHXRG_CORR_PINK          3           # Correlated Pink noise\nHXRG_UNCORR_PINK        1           # Uncorrelated Pink noise\nHXRG_ALT_COL_NOISE      0.5         # Alternating Column noise",
            "title": "NXRG Noise Generator package parameters"
        },
        {
            "location": "/API/",
            "text": "The SimCADO API\n\n\nComing soon",
            "title": "API Documentation"
        },
        {
            "location": "/API/#the-simcado-api",
            "text": "Coming soon",
            "title": "The SimCADO API"
        }
    ]
}