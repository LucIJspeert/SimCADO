<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>simcado.spectral &mdash; simcado 0.2dev documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.2dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="simcado 0.2dev documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for simcado.spectral</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Classes for spectral curves&quot;&quot;&quot;</span>
<span class="c1">###############################################################################</span>
<span class="c1"># spectral</span>
<span class="c1">#</span>
<span class="c1"># DESCRIPTION</span>
<span class="c1">#</span>
<span class="c1"># &quot;If you pay peanuts, you get monkeys&quot;</span>
<span class="c1">#</span>
<span class="c1"># A spectral is the base class for either a transmission curve or an</span>
<span class="c1"># emission curve. The main attributes are 2 equal length arrays holding the</span>
<span class="c1"># centres of each wavelength bin and the corresponding value - an energy or a</span>
<span class="c1"># transmission factor [0-1]</span>
<span class="c1">#  - lam</span>
<span class="c1">#  - val</span>
<span class="c1">#</span>
<span class="c1"># spectral should be overloaded on the + and * operators. Although a rebin</span>
<span class="c1"># method would be good, this is unique to the subclasses. E.g. a</span>
<span class="c1"># Throughput curve rebin would involve averaging the &quot;val&quot; values, while a</span>
<span class="c1"># spectral rebin would involve summing up the &quot;val&quot; values.</span>
<span class="c1">#</span>
<span class="c1"># spectral also needs the file path of the data:</span>
<span class="c1">#  - filename</span>
<span class="c1">#</span>
<span class="c1"># A Throughput curve doesn&#39;t need anything else on top of the spectral,</span>
<span class="c1"># however the EmissionCurve must know which units are being used so that it</span>
<span class="c1"># can immediately convert the energy into photons. In order to do this the</span>
<span class="c1"># EmissionCurve needs the following extra info from the commands dictionary</span>
<span class="c1">#  - spatial area [m2]</span>
<span class="c1">#  - angular area [arcsec2]</span>
<span class="c1">#  - integration time [s]</span>
<span class="c1">#</span>
<span class="c1"># As stated above each subclass should have its own rebin(lam_res) method</span>
<span class="c1">#</span>
<span class="c1"># Notes:</span>
<span class="c1"># All wavelength values are in [um]</span>
<span class="c1"># All other values are either transmission [0-1] or number of photons [&gt;=0]</span>
<span class="c1">#</span>
<span class="c1"># Classes:</span>
<span class="c1">#  spectral(object)</span>
<span class="c1">#  - from_file(filename)</span>
<span class="c1">#  - from_list([ThroughputCurve])</span>
<span class="c1">#  - from_skycalc(filename)</span>
<span class="c1">#</span>
<span class="c1"># Subclasses:</span>
<span class="c1"># Emission(spectral)</span>
<span class="c1"># - rebin(lam)</span>
<span class="c1"># Throughput(spectral)</span>
<span class="c1"># - rebin(lam)</span>
<span class="c1">#</span>
<span class="c1"># Methods:</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">constants</span> <span class="k">as</span> <span class="n">c</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">fits</span><span class="p">,</span> <span class="n">ascii</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;TransmissionCurve&quot;</span><span class="p">,</span> <span class="s2">&quot;EmissionCurve&quot;</span><span class="p">,</span> <span class="s2">&quot;BlackbodyCurve&quot;</span><span class="p">,</span> <span class="s2">&quot;UnityCurve&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="TransmissionCurve"><a class="viewcode-back" href="../../code.html#simcado.spectral.TransmissionCurve">[docs]</a><span class="k">class</span> <span class="nc">TransmissionCurve</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Very basic class to either read in a text file for a transmission curve</span>
<span class="sd">    or take two vectors to make a transmission curve</span>

<span class="sd">    List of kwargs:</span>
<span class="sd">    lam: [um] 1D numpy array of length n</span>
<span class="sd">    val: 1D numpy array of length n</span>
<span class="sd">    lam_res: [um] float with the desired spectral resolution</span>
<span class="sd">    or</span>
<span class="sd">    filename: string with the path to the transmission curve file where</span>
<span class="sd">              the first column is wavelength in [um] and the second is the</span>
<span class="sd">              transmission coefficient between [0,1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># TODO: remove automatic resampling to lam_res. This should</span>
        <span class="c1">#       only be done when requested (i.e. lam_res in kwargs)</span>
        <span class="c1"># See answer below</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lam_res&quot;</span>   <span class="p">:</span><span class="mf">0.001</span><span class="p">,</span>
                       <span class="s2">&quot;Type&quot;</span>      <span class="p">:</span><span class="s2">&quot;Transmission&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;min_step&quot;</span>  <span class="p">:</span><span class="mf">1E-4</span><span class="p">,</span>
                       <span class="s2">&quot;lam_unit&quot;</span>  <span class="p">:</span><span class="n">u</span><span class="o">.</span><span class="n">um</span><span class="p">}</span>
        
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filename</span>
                       
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lam_orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_orig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_orig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_orig</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;lam_unit&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">um</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

        <span class="c1">## OC: resampling should only be done when necessary</span>
        <span class="c1">## KL: This ensures that the curves are on a regular grid. Not all of</span>
        <span class="c1">## the filter curve .dat files have regular bin spacing and so it is</span>
        <span class="c1">## impossible to define a &quot;lam_res&quot; for those curves. This is needed for</span>
        <span class="c1">## the EmissionCurve function &quot;photons_in_range(lam_min, lam_max)&quot;</span>
        <span class="c1">##</span>
        <span class="c1">## We could always implement a catch for irregular bin spacing and only</span>
        <span class="c1">## resample those curves.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Emission&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;lam_res&quot;</span><span class="p">],</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;lam_res&quot;</span><span class="p">],</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Spectral curve:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;Curve </span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]])[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> \
                                    <span class="o">+</span><span class="s2">&quot; ...&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">]])[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the wavelength and value vectors from the input parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;lam&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="s2">&quot;val&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">lam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;lam&quot;</span><span class="p">]</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>

        <span class="c1"># test if it is a skycalc file</span>
        <span class="k">elif</span> <span class="s2">&quot;filename&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;.fits&quot;</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span>
                <span class="n">hdr</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">getheader</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="s2">&quot;SKYCALC&quot;</span> <span class="ow">in</span> <span class="n">hdr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hdr</span><span class="p">))</span> \
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Emission&quot;</span><span class="p">:</span>
                        <span class="n">lam</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="s2">&quot;lam&quot;</span><span class="p">]</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lam</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="s2">&quot;lam&quot;</span><span class="p">]</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="s2">&quot;trans&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s2">&quot;../data/skytable.fits&quot;</span><span class="p">)</span>
                    <span class="n">lam</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">ascii</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;filename&quot;</span><span class="p">])</span>
                <span class="n">lam</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">colnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">colnames</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please pass either filename or lam/val keywords&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lam</span><span class="p">,</span> <span class="n">val</span>


<div class="viewcode-block" id="TransmissionCurve.resample"><a class="viewcode-back" href="../../code.html#simcado.spectral.TransmissionCurve.resample">[docs]</a>    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">,</span> <span class="n">use_edges</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">min_step</span><span class="o">=</span><span class="mf">1E-5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resamples both the wavelength and value vectors to an even grid.</span>
<span class="sd">        In order to avoid losing spectral information, the TransmissionCurve</span>
<span class="sd">        resamples down to a resolution of &#39;min_step&#39; (default: 0.01nm)</span>
<span class="sd">        before resampling again up to the given sampling vector defined by</span>
<span class="sd">        &#39;bins&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        - bins: [um]: float - taken to mean the width of bins on an even grid</span>
<span class="sd">                      array - the centres of the spectral bins</span>
<span class="sd">                            - the edges of the spectral bins if use_edges = True</span>

<span class="sd">        Optional parameters</span>
<span class="sd">        ===================</span>
<span class="sd">        - action: [&#39;average&#39;,&#39;sum&#39;] How to rebin the spectral curve. If &#39;sum&#39;,</span>
<span class="sd">                  then the curve is normalised against the integrated value of</span>
<span class="sd">                  the original curve. If &#39;average&#39;, the average value per bin</span>
<span class="sd">                  becomes the value for each bin.</span>
<span class="sd">        - use_edges: [False, True] True if the array passed in &#39;bins&#39; describes</span>
<span class="sd">                     the edges of the wavelength bins.</span>
<span class="sd">        - min_step: [um] default=1E-5, the step size for the down-sample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#####################################################</span>
        <span class="c1"># Work out the irregular grid problem while summing #</span>
        <span class="c1">#####################################################</span>

        <span class="n">tmp_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_orig</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;min_step&quot;</span><span class="p">])</span>
        <span class="n">tmp_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">tmp_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_orig</span><span class="p">)</span>

        <span class="c1"># if bins is a single number, use it as the bin width</span>
        <span class="c1"># else as the bin centres</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
            <span class="n">lam_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_orig</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">1E-7</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lam_tmp</span> <span class="o">=</span> <span class="n">bins</span>

        <span class="n">lam_res</span> <span class="o">=</span> <span class="n">lam_tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lam_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">min_step</span> <span class="o">&gt;=</span> <span class="n">lam_res</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;min_step &gt; resample resolution. Can&#39;t resample&quot;</span><span class="p">)</span>

        <span class="c1"># define the edges and centres of each wavelength bin</span>
        <span class="k">if</span> <span class="n">use_edges</span><span class="p">:</span>
            <span class="n">lam_bin_edges</span> <span class="o">=</span> <span class="n">lam_tmp</span>
            <span class="n">lam_bin_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">lam_tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">lam_tmp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lam_bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lam_tmp</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">lam_res</span><span class="p">,</span>
                                      <span class="n">lam_tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">lam_res</span><span class="p">)</span>
            <span class="n">lam_bin_centers</span> <span class="o">=</span> <span class="n">lam_tmp</span>

        <span class="c1"># here is the assumption of a regular grid - see res_tmp</span>
        <span class="n">val_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">lam_bin_centers</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lam_bin_centers</span><span class="p">)):</span>

            <span class="n">mask_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">tmp_x</span> <span class="o">&gt;</span> <span class="n">lam_bin_edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span>
                              <span class="p">(</span><span class="n">tmp_x</span> <span class="o">&lt;</span> <span class="n">lam_bin_edges</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask_i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;average&quot;</span><span class="p">:</span>
                <span class="n">val_tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">tmp_y</span><span class="p">[</span><span class="n">mask_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">mask_i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask_i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
                <span class="c1"># FIXED. THE SUMMING ISSUE. TEST IT         #</span>
                <span class="c1"># Tested - the errors are on the 0.1% level #</span>
                <span class="n">val_tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">tmp_y</span><span class="p">[</span><span class="n">mask_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">mask_i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val_tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># The summing issue - assuming we want to integrate along the curve,</span>
        <span class="c1"># i.e. count all the photons in a new set of bins, we need to integrate</span>
        <span class="c1"># along the well-sampled (1E-5um) curve. However the above line of code</span>
        <span class="c1"># using np.interp doesn&#39;t take into account the new bin width when</span>
        <span class="c1"># resampling down to 1E-5um. I account for this summing up all the</span>
        <span class="c1"># photons in the original data set and normalising the new 1E-5 bin</span>
        <span class="c1"># data set to have the same amount.</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span> <span class="n">val_tmp</span> <span class="o">*=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_orig</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">val_tmp</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">=</span> <span class="n">lam_tmp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val_tmp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span> <span class="n">lam_res</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;lam_res&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span></div>

<div class="viewcode-block" id="TransmissionCurve.normalize"><a class="viewcode-back" href="../../code.html#simcado.spectral.TransmissionCurve.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;integral&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normalize the spectral curve</span>

<span class="sd">        - mode=&quot;integral&quot; normalizes the integral over the defined</span>
<span class="sd">               wavelength range to val (default: 1.)</span>
<span class="sd">        - mode=&quot;maximum&quot; normalizes the maximum over the defined</span>
<span class="sd">               wavelength range to val (default: 1.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;integral&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;maximum&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">errorstr</span> <span class="o">=</span> <span class="s2">&quot;Unknown normalization mode: {0}. No action taken.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errorstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>

    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TransmissionCurve.val to the power of n.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tcnew</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">tcnew</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">tcnew</span><span class="o">.</span><span class="n">val</span> <span class="o">**</span> <span class="n">n</span>

        <span class="n">tcnew</span><span class="o">.</span><span class="n">lam_orig</span> <span class="o">=</span> <span class="n">tcnew</span><span class="o">.</span><span class="n">lam</span>
        <span class="n">tcnew</span><span class="o">.</span><span class="n">val_orig</span> <span class="o">=</span> <span class="n">tcnew</span><span class="o">.</span><span class="n">val</span>

        <span class="k">return</span> <span class="n">tcnew</span>

    <span class="c1"># def __mul__(self, tc):</span>
        <span class="c1"># &quot;&quot;&quot;</span>
        <span class="c1"># Product of a TransmissionCurve with a scalar or another Curve</span>
        <span class="c1"># If tc is a TransmissionCurve and does not have the same lam, it is</span>
        <span class="c1"># resampled first.</span>
        <span class="c1"># &quot;&quot;&quot;</span>

        <span class="c1"># tcnew = deepcopy(self)</span>

        <span class="c1"># if not hasattr(tc, &quot;val&quot;):</span>
            <span class="c1"># tcnew.val *= tc</span>
        <span class="c1"># else:</span>
            <span class="c1"># ### TODO: This comparison needs work</span>
            <span class="c1"># if not np.all(self.lam == tc.lam):</span>
                <span class="c1"># tc.resample(self.lam)</span>
            <span class="c1"># tcnew.val *= tc.val</span>

        <span class="c1"># tcnew.lam_orig = tcnew.lam</span>
        <span class="c1"># tcnew.val_orig = tcnew.val</span>

        <span class="c1"># return tcnew        </span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Product of a TransmissionCurve with a scalar or another Curve</span>
<span class="sd">        If tc is a TransmissionCurve and does not have the same lam, it is</span>
<span class="sd">        resampled first.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tcnew</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        
        <span class="c1"># EmissionCUrve takes precedence over TransmissionCurve</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">EmissionCurve</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">EmissionCurve</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tc</span> <span class="o">*</span> <span class="n">tcnew</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="s2">&quot;val&quot;</span><span class="p">):</span>
            <span class="n">tcnew</span><span class="o">.</span><span class="n">val</span> <span class="o">*=</span> <span class="n">tc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">### TODO: This comparison needs work</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">==</span> <span class="n">tc</span><span class="o">.</span><span class="n">lam</span><span class="p">):</span>
                <span class="n">tc</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">)</span>
            <span class="n">tcnew</span><span class="o">.</span><span class="n">val</span> <span class="o">*=</span> <span class="n">tc</span><span class="o">.</span><span class="n">val</span>

        <span class="n">tcnew</span><span class="o">.</span><span class="n">lam_orig</span> <span class="o">=</span> <span class="n">tcnew</span><span class="o">.</span><span class="n">lam</span>
        <span class="n">tcnew</span><span class="o">.</span><span class="n">val_orig</span> <span class="o">=</span> <span class="n">tcnew</span><span class="o">.</span><span class="n">val</span>

        <span class="k">return</span> <span class="n">tcnew</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Addition of a TransmissionCurve with a scalar or another Curve.</span>
<span class="sd">        If tc is a TransmissionCurve and does not have the same lam, it is</span>
<span class="sd">        resampled first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tcnew</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="s2">&quot;val&quot;</span><span class="p">):</span>
            <span class="n">tcnew</span><span class="o">.</span><span class="n">val</span> <span class="o">+=</span> <span class="n">tc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">### TODO: This comparison needs work</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">==</span> <span class="n">tc</span><span class="o">.</span><span class="n">lam</span><span class="p">):</span>
                <span class="n">tc</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">)</span>
            <span class="n">tcnew</span><span class="o">.</span><span class="n">val</span> <span class="o">+=</span> <span class="n">tc</span><span class="o">.</span><span class="n">val</span>

        <span class="n">tcnew</span><span class="o">.</span><span class="n">lam_orig</span> <span class="o">=</span> <span class="n">tcnew</span><span class="o">.</span><span class="n">lam</span>
        <span class="n">tcnew</span><span class="o">.</span><span class="n">val_orig</span> <span class="o">=</span> <span class="n">tcnew</span><span class="o">.</span><span class="n">val</span>

        <span class="k">return</span> <span class="n">tcnew</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tc</span><span class="p">):</span>
        <span class="k">return</span>  <span class="bp">self</span><span class="o">.</span><span class="n">__add__</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">tc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mul__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__mul__</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mul__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sub__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>



<div class="viewcode-block" id="EmissionCurve"><a class="viewcode-back" href="../../code.html#simcado.spectral.EmissionCurve">[docs]</a><span class="k">class</span> <span class="nc">EmissionCurve</span><span class="p">(</span><span class="n">TransmissionCurve</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for emission curves</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    - lam: [um] 1D numpy array of length n</span>
<span class="sd">    - val: 1D numpy array of length n</span>
<span class="sd">    - res: [um] float with the desired spectral resolution</span>
<span class="sd">    - filename: string with the path to the transmission curve file where</span>
<span class="sd">                the first column is wavelength in [um] and the second is the</span>
<span class="sd">                transmission coefficient between [0,1]</span>
<span class="sd">    - pix_res: [arcsec] float of int for the field of view for each pixel</span>
<span class="sd">    - area: [m2] float or int for the collecting area of M1</span>
<span class="sd">    - units: string or astropy.unit for calculating the number of photons</span>
<span class="sd">             per voxel</span>

<span class="sd">    Return values are in [ph/s/voxel]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span>  <span class="s2">&quot;exptime&quot;</span> <span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                            <span class="s2">&quot;pix_res&quot;</span> <span class="p">:</span><span class="mf">0.004</span><span class="p">,</span>
                            <span class="s2">&quot;area&quot;</span>    <span class="p">:</span><span class="mi">978</span><span class="p">,</span>
                            <span class="s2">&quot;units&quot;</span>   <span class="p">:</span><span class="s2">&quot;ph/(s m2 micron arcsec2)&quot;</span><span class="p">}</span>
        <span class="k">if</span> <span class="s2">&quot;units&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;No &#39;units&#39; specified in EmissionCurve.</span>
<span class="s2">                          Assuming ph/(s m2 micron arcsec2)&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">default_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">EmissionCurve</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">Type</span> <span class="o">=</span> <span class="s2">&quot;Emission&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">default_params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_photons</span><span class="p">()</span>

<div class="viewcode-block" id="EmissionCurve.resample"><a class="viewcode-back" href="../../code.html#simcado.spectral.EmissionCurve.resample">[docs]</a>    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="n">use_edges</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rebin an emission curve&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EmissionCurve</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">action</span><span class="p">,</span>
                                            <span class="n">use_edges</span><span class="o">=</span><span class="n">use_edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmissionCurve.convert_to_photons"><a class="viewcode-back" href="../../code.html#simcado.spectral.EmissionCurve.convert_to_photons">[docs]</a>    <span class="k">def</span> <span class="nf">convert_to_photons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do the conversion to photons/s/voxel by using the val_unit, lam, area</span>
<span class="sd">        and exptime keywords. If not given, make some assumptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">])</span>
        <span class="n">bases</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">bases</span>

        <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span>

        <span class="c1"># The delivered EmissionCurve should be in ph/s/voxel</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span>  <span class="ow">not</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span> <span class="n">factor</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;exptime&quot;</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">s</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">m</span>      <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span> <span class="n">factor</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">arcsec</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span> <span class="n">factor</span> <span class="o">*=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;pix_res&quot;</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">arcsec</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">micron</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span> <span class="n">factor</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;lam_res&quot;</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">um</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">unit</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">*=</span> <span class="n">factor</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span></div>

<div class="viewcode-block" id="EmissionCurve.photons_in_range"><a class="viewcode-back" href="../../code.html#simcado.spectral.EmissionCurve.photons_in_range">[docs]</a>    <span class="k">def</span> <span class="nf">photons_in_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam_min</span><span class="p">,</span> <span class="n">lam_max</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sum up the photons in between the wavelength boundaries, lam_min lam_max</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        - lam_min, lam_max: the wavelength limits</span>
<span class="sd">        </span>
<span class="sd">        Return values are in [ph/s/pixel]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lam_min</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">lam_max</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;wavelength limits outside wavelength range&quot;</span><span class="p">)</span>
            <span class="n">photons</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">lam_max</span> <span class="o">-</span> <span class="n">lam_min</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">:</span>
                <span class="n">zoom</span> <span class="o">=</span> <span class="mi">10</span>
                <span class="n">lam_zoom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lam_min</span><span class="p">,</span> <span class="n">lam_max</span><span class="p">,</span> <span class="n">zoom</span><span class="p">)</span>
                <span class="n">spec_zoom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">lam_zoom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">/</span> <span class="n">zoom</span>
                <span class="n">photons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spec_zoom</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">&gt;=</span> <span class="n">lam_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">&lt;</span> <span class="n">lam_max</span><span class="p">)</span>
                <span class="n">photons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">photons</span></div></div>


<div class="viewcode-block" id="BlackbodyCurve"><a class="viewcode-back" href="../../code.html#simcado.spectral.BlackbodyCurve">[docs]</a><span class="k">class</span> <span class="nc">BlackbodyCurve</span><span class="p">(</span><span class="n">EmissionCurve</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Blackbody emission curve</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    - lam: 1D numpy array of length n in [um]</span>
<span class="sd">    - temp: [deg C] float for the average temperature of the blackbody</span>
<span class="sd">    - pix_res: [arcsec] float or int for the field of view for each pixel</span>
<span class="sd">    - area: [m2] float or int for the emitting surface</span>
<span class="sd">    </span>
<span class="sd">    Return values are in units of [ph/s/voxel]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;pix_res&quot;</span><span class="p">:</span><span class="mf">0.004</span><span class="p">,</span> <span class="s2">&quot;area&quot;</span><span class="p">:</span><span class="mi">978</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">temp</span> <span class="o">+=</span> <span class="mf">273.15</span>

        <span class="n">lam_res</span> <span class="o">=</span> <span class="n">lam</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lam</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lam</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">lam_res</span><span class="p">,</span> <span class="n">lam</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">lam_res</span><span class="p">)</span>
        <span class="n">lam_res</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># I is in W sr-1 m-3 : [erg/s/sr/cm2/um]</span>
        <span class="n">I</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">h</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">lam</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">um</span><span class="p">)</span><span class="o">**</span><span class="mi">5</span> <span class="o">/</span> \
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">h</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">k_B</span> <span class="o">*</span> <span class="p">(</span><span class="n">temp</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">K</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">lam</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">um</span><span class="p">)))</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">sr</span>

        <span class="c1"># E is in W</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">I</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">lam_res</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">um</span><span class="p">)</span> <span class="o">*</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;pix_res&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">arcsec</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># ph is in 1/s</span>
        <span class="n">ph</span> <span class="o">=</span> <span class="n">E</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">h</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="n">lam</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">um</span><span class="p">))</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">ph</span><span class="o">.</span><span class="n">si</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">BlackbodyCurve</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;1/s&quot;</span><span class="p">,</span>
                                             <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Blackbody&quot;</span></div>

<div class="viewcode-block" id="UnityCurve"><a class="viewcode-back" href="../../code.html#simcado.spectral.UnityCurve">[docs]</a><span class="k">class</span> <span class="nc">UnityCurve</span><span class="p">(</span><span class="n">TransmissionCurve</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constant transmission curve</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    - lam [um]: wavelength array</span>
<span class="sd">    - val: constant value of transmission (default: 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">]),</span> <span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">val</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lam</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UnityCurve</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

        
        
<span class="k">class</span> <span class="nc">FilterSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    http://svo2.cab.inta-csic.es/svo/theory/fps3/index.php?mode=browse&amp;gname=Paranal</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Kieran Leschinski, Oliver Czoske.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
    </div>

    

    
  </body>
</html>